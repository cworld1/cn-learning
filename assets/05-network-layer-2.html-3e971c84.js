import{_ as l,M as i,p as r,q as o,R as s,t as a,N as e,a1 as t}from"./framework-9363aed8.js";const p="/assets/image-20230504180344082-077ed984.png",m="/assets/image-20230504180725563-971ac105.png",c="/assets/image-20230504181315974-4ce8c368.png",h="/assets/image-20230504182538261-7fcade07.png",d="/assets/image-20230511161522754-4641ffbe.png",u="/assets/image-20230511173436938-7f216046.png",g="/assets/image-20230511173842188-f593a0b4.png",y="/assets/image-20230217103850062-40225edc.png",x="/assets/image-20230218222118235-2237576b.png",f="/assets/image-20230511182105569-894ac6e5.png",w="/assets/image-20230511182639115-2b5c4e71.png",v={},k=t('<h2 id="outline" tabindex="-1"><a class="header-anchor" href="#outline" aria-hidden="true">#</a> Outline</h2><ol><li>introduction</li><li>routing protocols</li><li>intra-AS routing in the Internet: OSPF</li><li>routing among the ISPs: BGP</li><li>The SDN control plane <ul><li>link state</li><li>distance vector</li></ul></li><li>ICMP: The Internet Control Message Protocol</li><li>Network management and SNMP</li></ol>',2),b={href:"https://blog.csdn.net/weixin_53580595/article/details/129482346",target:"_blank",rel:"noopener noreferrer"},_=t('<h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><ul><li><p><strong>每个路由器控制（Per-router control）</strong>：每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。如下图所示：</p><p><img src="'+p+'" alt="image-20230504180344082" loading="lazy"></p></li><li><p><strong>逻辑集中式控制（Logically centralized control）</strong>：逻辑集中式控制器计算并分发转发表以供每台路由器使用，如下图所示：</p><p><img src="'+m+'" alt="image-20230504180725563" loading="lazy"></p></li></ul><h2 id="routing-protocols" tabindex="-1"><a class="header-anchor" href="#routing-protocols" aria-hidden="true">#</a> Routing protocols</h2><p><em>goal:</em> determine(确定) “good” paths (equivalently, routes 等效于路由器), from sending hosts to receiving host, through network of routers</p><h3 id="introduction-of-routing-protocols" tabindex="-1"><a class="header-anchor" href="#introduction-of-routing-protocols" aria-hidden="true">#</a> Introduction of Routing protocols</h3><h4 id="graph-abstraction-of-the-network" tabindex="-1"><a class="header-anchor" href="#graph-abstraction-of-the-network" aria-hidden="true">#</a> Graph abstraction of the network</h4><p><img src="'+c+'" alt="image-20230504181315974" loading="lazy"></p><p>其中：</p>',8),S=s("ul",null,[s("li",null,[s("p",null,[a("graph: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"G"),s("mo",null,"="),s("mo",{stretchy:"false"},"("),s("mi",null,"N"),s("mo",{separator:"true"},","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"G = (N,E)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal"},"G"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])])])]),s("li",null,[s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"N"),s("mo",null,"="),s("mtext",null,"set of routers"),s("mo",null,"="),s("mrow",null,[s("mi",null,"u"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",{separator:"true"},","),s("mi",null,"w"),s("mo",{separator:"true"},","),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{separator:"true"},","),s("mi",null,"z")])]),s("annotation",{encoding:"application/x-tex"},"N = \\text{set of routers} = { u, v, w, x, y, z }")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"set of routers")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])])])])]),s("li",null,[s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"E"),s("mo",null,"="),s("mtext",null,"set of links"),s("mo",null,"="),s("mo",{stretchy:"false"},"{"),s("mo",{stretchy:"false"},"("),s("mi",null,"u"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"u"),s("mo",{separator:"true"},","),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"v"),s("mo",{separator:"true"},","),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"v"),s("mo",{separator:"true"},","),s("mi",null,"w"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"w"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"w"),s("mo",{separator:"true"},","),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"w"),s("mo",{separator:"true"},","),s("mi",null,"z"),s("mo",{stretchy:"false"},")"),s("mo",{separator:"true"},","),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{separator:"true"},","),s("mi",null,"z"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},"}")]),s("annotation",{encoding:"application/x-tex"},"E = \\text{set of links} = \\{ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) \\}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"set of links")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"{("),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"u"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mclose"},")"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mclose"},")}")])])])])]),s("li",null,[s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"c"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"x"),s("mtext",null,"’"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mtext",null,"cost of link "),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"x"),s("mtext",null,"’"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"c(x,x’) = \\text{cost of link}\\ (x,x’)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"c"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mord"},"’"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"cost of link")]),s("span",{class:"mspace"}," "),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mord"},"’"),s("span",{class:"mclose"},")")])])])]),s("p",null,[a("e.g., "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"c"),s("mo",{stretchy:"false"},"("),s("mi",null,"w"),s("mo",{separator:"true"},","),s("mi",null,"z"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mn",null,"5")]),s("annotation",{encoding:"application/x-tex"},"c(w,z) = 5")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"c"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02691em"}},"w"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"5")])])])])])],-1),P=t(`<h4 id="routing-algorithm" tabindex="-1"><a class="header-anchor" href="#routing-algorithm" aria-hidden="true">#</a> Routing algorithm</h4><p>即路由选择算法。</p><p>分类上，从 global or decentralized information:</p><ul><li><p><em>global:</em> all routers have complete topology, link cost info 都有完整的拓扑结构，链路成本信息</p></li><li><p><em>decentralized:</em> router knows physically-connected neighbors, link costs to neighbors 路由器知道物理连接的邻居，与邻居的链路成本</p><p>iterative process of computation, exchange of info with neighbors 计算的迭代过程，与邻居交换信息</p></li></ul><p>从 static or dynamic:</p><ul><li><p><em>static</em>: routes change slowly over time</p></li><li><p><em>dynamic</em>: routes change more quickly</p><p>periodic update 定期更新 in response to link cost changes 响应链接成本总是保持变化的</p></li></ul><p>算法上：</p><ul><li>集中式路由选择算法（centralized routing algorithm）：用完整、全局性的网络知识计算出从源到目的地之间的最低开销路径。具有全局状态信息的算法常被称作链路状态（Link State，LS）算法，因为该算法必须知道网络中每条链路的开销。</li><li>分散式路由选择算法（decentralized routing algorithm）：路由器以迭代、分布式计算的方式计算出最低开销路径。没有节点拥有关于网络链路开销的完整信息。一个分散式路由选择算法为距离向量（Distance-Vector，DV）算法，每个节点维护到网络中所有其他节点的开销估计的向量。</li></ul><h3 id="link-state" tabindex="-1"><a class="header-anchor" href="#link-state" aria-hidden="true">#</a> Link state</h3><p>在实践中，这经常由链路状态广播（link state broadcast）算法完成。下面给出的链路状态路由选择算法叫做 Dijkstra 算法，其计算从某节点（源节点 u）到网络中所有其他节点的最低开销路径。</p><p>基本思想：经算法的第 k 次迭代后，可知道到 k 个目的节点的最低开销路径，在到所有目的节点的最低开销路径之中，这 k 条路径具有 k 个最低开销。</p><p>我们定义如下符号：</p><ul><li><code>D(v)</code>：到算法的本次迭代，从源节点到目的节点 v 的最低开销；</li><li><code>p(v)</code>：从源到 v 沿着当前最小开销路径的前一个节点（v 的邻居）；</li><li><code>N&#39;</code>：节点子集；如果从源到 v 的最低开销路径已经确定，v 在<code>N&#39;</code>中。</li></ul><p>源节点 u 的链路状态（LS）算法如下：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># Initialization:</span>
N&#39; <span class="token operator">=</span> <span class="token punctuation">{</span>u<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token builtin">all</span> nodes v
<span class="token keyword">if</span> v adjacent to u
    then D<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> c<span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span>
<span class="token keyword">else</span> D<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> ∞

<span class="token comment"># Loop</span>
find w <span class="token keyword">not</span> <span class="token keyword">in</span> N&#39; such that D<span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token keyword">is</span> a minimum
add w to N&#39;
update D<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token builtin">all</span> v adjacent to w <span class="token keyword">and</span> <span class="token keyword">not</span> <span class="token keyword">in</span> N&#39; <span class="token punctuation">:</span>
    D<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span> D<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">(</span>w<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token operator">*</span> new cost to v <span class="token keyword">is</span> either old cost to v <span class="token keyword">or</span> known
shortest path cost to w plus cost <span class="token keyword">from</span> w to v <span class="token operator">*</span><span class="token operator">/</span>
<span class="token comment"># until all nodes in N&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于下图的网络，链路状态算法迭代运行如下：</p><p><img src="`+h+'" alt="image-20230504182538261" loading="lazy"></p><table><thead><tr><th>Step</th><th>N&#39;</th><th>D(v),p(v)</th><th>D(w),p(w)</th><th>D(x),p(x)</th><th>D(y),p(y)</th><th>D(z),p(z)</th></tr></thead><tbody><tr><td>0</td><td>u</td><td>2,u</td><td>5,u</td><td>1,u</td><td>∞</td><td>∞</td></tr><tr><td>1</td><td>ux</td><td>2,u</td><td>4,x</td><td></td><td>2,x</td><td>∞</td></tr><tr><td>2</td><td>uxy</td><td>2,u</td><td>3,y</td><td></td><td></td><td>4,y</td></tr><tr><td>3</td><td>uxyv</td><td></td><td>3,y</td><td></td><td></td><td>4,y</td></tr><tr><td>4</td><td>uxyvw</td><td></td><td></td><td></td><td></td><td>4,y</td></tr><tr><td>5</td><td>uxyvwz</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>路线上的流量变化和拥塞会使 LS 算法产生 <strong>路由震荡（Routing Oscillations）</strong>。</p><h3 id="distance-vector" tabindex="-1"><a class="header-anchor" href="#distance-vector" aria-hidden="true">#</a> Distance vector</h3><p>距离向量（Distance-Vector，DV）算法是一种迭代的（iterative）、异步的（asynchronous）、分布式的（distributed）和自我终止的（self-termination）。</p><div class="custom-container tip"><p>这种方法没有组建图，只通过方程不断迭代更新数据，收集了与邻居之间的信息。</p></div>',22),z=s("p",null,[a("令 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"d"),s("mi",null,"x")]),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"d_x(y)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"d"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"x")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])]),a(" 是从节点 x 到节点 y 的最低开销路径。则该最低开销与著名的 Bellman-Ford 方程相关，即：")],-1),D=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"d"),s("mi",null,"x")]),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("munder",null,[s("mrow",null,[s("mi",null,"min"),s("mo",null,"⁡")]),s("mi",null,"v")]),s("mrow",null,[s("mi",null,"c"),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{separator:"true"},","),s("mi",null,"v"),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("msub",null,[s("mi",null,"d"),s("mi",null,"v")]),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")")])]),s("annotation",{encoding:"application/x-tex"}," d_x(y)=\\min_v{c(x,v)+d_v(y)} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"d"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"x")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.45em","vertical-align":"-0.7em"}}),s("span",{class:"mop op-limits"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6679em"}},[s("span",{style:{top:"-2.4em","margin-left":"0em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"v")])]),s("span",{style:{top:"-3em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",null,[s("span",{class:"mop"},"min")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.7em"}},[s("span")])])])]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"c"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"d"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"v")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])])])])],-1),N=s("p",null,[a("方程中的 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mrow",null,[s("mi",null,"min"),s("mo",null,"⁡")]),s("mi",null,"v")])]),s("annotation",{encoding:"application/x-tex"},"\\min_v")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8179em","vertical-align":"-0.15em"}}),s("span",{class:"mop"},[s("span",{class:"mop"},"min"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03588em"}},"v")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])])])])]),a(" 是对于 x 的所有邻居的。")],-1),M=s("p",null,[a("算法基本思想：每个节点 x 以 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"D"),s("mi",null,"x")]),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"D_x(y)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"x")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")")])])]),a(" 开始，对在 N 中的所有节点 y，估计从 x 到 y 的最低开销路径的开销路径。")],-1),A=t('<p>DV 算法具体实例如下：</p><p><img src="'+d+'" alt="image-20230511161522754" loading="lazy"></p><h4 id="链路开销改变与链路故障" tabindex="-1"><a class="header-anchor" href="#链路开销改变与链路故障" aria-hidden="true">#</a> 链路开销改变与链路故障</h4><p>链路开销发生改变：</p><ul><li>node detects local link cost change 节点检测本地链路成本变化</li><li>updates routing info, recalculates distance vector 重新计算距离矢量</li><li>if DV changes, notify neighbors</li></ul><p>有时当链路中有一条路的距离极长甚至接近于开路，这时我们会遇到<strong>路由选择环路（routing loop）</strong>，这样的问题也被称为**无穷计数（count-to-infinity）**问题。</p><h4 id="距离向量算法-增加毒性逆转" tabindex="-1"><a class="header-anchor" href="#距离向量算法-增加毒性逆转" aria-hidden="true">#</a> 距离向量算法：增加毒性逆转</h4><p>毒性逆转（poisoned reverse），思想：如果 z 通过 y 路由选择目的地 x，则 z 将通告 y，它到 x 的距离是无穷大，也就是 z 将通告：</p>',8),B=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"D"),s("mi",null,"z")]),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",{stretchy:"false"},")"),s("mo",null,"="),s("mi",{mathvariant:"normal"},"∞")]),s("annotation",{encoding:"application/x-tex"}," D_z(x)=\\infin ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.04398em"}},"z")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord"},"∞")])])])])],-1),G=s("p",null,"但毒性逆转并不能解决一般的无穷计数问题。",-1),I=s("h3",{id:"comparison-of-ls-and-dv-algorithms",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#comparison-of-ls-and-dv-algorithms","aria-hidden":"true"},"#"),a(" Comparison of LS and DV algorithms")],-1),O=s("p",null,"message complexity 消息复杂性:",-1),L=s("ul",null,[s("li",null,[s("p",null,[a("LS: with n nodes, E links, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(nE)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a(" msgs sent")])]),s("li",null,[s("p",null,"DV: exchange between neighbors only"),s("p",null,"convergence time varies 收敛时间不同")])],-1),E=s("p",null,"speed of convergence 收敛速度:",-1),C=s("ul",null,[s("li",null,[s("p",null,[a("LS: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n^2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mclose"},")")])])]),a(" algorithm requires "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"E"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(nE)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),s("span",{class:"mclose"},")")])])]),a(" msgs")]),s("p",null,"may have oscillations 可能有震荡")]),s("li",null,[s("p",null,"DV: convergence time varies"),s("p",null,"may be routing loops 可能是路由环路"),s("p",null,"count-to-infinity problem 计数无穷大问题")])],-1),V=t('<div class="custom-container tip"><p class="custom-container-title">robustness: what happens if router malfunctions?</p><p>稳健性：如果路由器出现故障会怎样？</p><p>LS:</p><ul><li>node can advertise incorrect link cost 节点可以通告不正确的链接成本</li><li>each node computes only its own table 每个节点仅计算自己的表</li></ul><p>DV:</p><ul><li>DV node can advertise incorrect path cost DV 节点可以通告不正确的路径成本</li><li>each node’s table used by others 其他节点使用的每个节点的表</li><li>error propagate thru network 错误也会通过网络传播</li></ul></div><h2 id="intra-as-routing-in-the-internet-ospf" tabindex="-1"><a class="header-anchor" href="#intra-as-routing-in-the-internet-ospf" aria-hidden="true">#</a> Intra-AS routing in the Internet: OSPF</h2><p>因特网中自治系统内部的路由选择：OSPF（开放最短路优先 Open Shortest Path First）</p><p>随着路由器规模增大和管理自治的要求，可以通过将路由器组织进自治系统（Autonomous System，AS）来解决。在一个自治系统内运行的路由算法叫做自治系统内部路由选择协议（intra-autonomous system routing protocol）。</p><div class="custom-container tip"><p class="custom-container-title">市面上的常见路由协议</p><p>基于 DV:</p><ul><li><p>RIP</p></li><li><p>IGRP</p></li><li><p>EIGRP</p></li></ul><p>基于 LS:</p><ul><li><p>OSPF（主流）</p></li><li><p>IS-IS</p></li></ul></div><p>OSPF 是一种链路状态协议，它使用洪泛链路状态信息和 Dijkstra 最低开销路径算法。使用 OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行 Dijkstra 的最短路径算法，以确定一个自身为根节点到所有子网的最短路径树。</p><p>使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。</p><p>OSPF 的优点：</p><ul><li>安全（Security）：能够鉴别 OSPF 路由器之间的交换；</li><li>多条相同开销的路径（Multiple same-cost paths）：允许使用多条路径；</li><li>对单播与多播路由选择的综合支持（Integrated support for unicast and multicast routing）；</li><li>支持在单个 AS 中的层次结构（Support for hierarchy within a single AS）。</li></ul><h2 id="routing-among-the-isps-bgp" tabindex="-1"><a class="header-anchor" href="#routing-among-the-isps-bgp" aria-hidden="true">#</a> routing among the ISPs: BGP</h2><p>当分组跨越多个 AS 进行路由时，我们需要一个<strong>自治系统间路由协议（inter-autonomous system routing protocol）</strong>。在因特网中，所有的 AS 运行相同的 AS 间路由选择协议，称为<strong>边界网关协议（Broder Gateway Protocol，BGP）</strong>。</p><p>BGP provides each AS a means to:</p><ul><li><strong>eBGP</strong>: obtain subnet reachability information from neighboring ASes. 从相邻 AS 获取子网可访问性信息</li><li><strong>iBGP</strong>: propagate reachability information to all AS-internal routers. 将可达性信息传播到所有 AS 内部路由器</li></ul><p>and it determines “good” routes to other networks based on reachability information and <em>policy</em>(可达性信息和策略)</p><h3 id="bgp-的作用" tabindex="-1"><a class="header-anchor" href="#bgp-的作用" aria-hidden="true">#</a> BGP 的作用</h3><p>在 BGP 中，分组并不是路由到一个特定的目的地址，相反是路由到 CIDR 化的前缀，其中每个前缀表示一个子网或者一个子网集合。</p><p>BGP 为每台服务器提供完成以下任务的手段：</p><ul><li><p>从邻居 AS 获得前缀的可达性信息 Obtain prefix reachability information from neighboring ASs；</p></li><li><p>确定到该前缀的“最好”的路由 Determine the “best” routes to the prefixes.</p></li></ul><h3 id="ebgp-ibgp-connections" tabindex="-1"><a class="header-anchor" href="#ebgp-ibgp-connections" aria-hidden="true">#</a> eBGP, iBGP connections</h3><p>通告 BGP 路由信息</p><p>对于每个 AS，每台路由器要么是一台网关路由器（getaway router），要么是一台内部路由器（internal router）。在 BGP 中，每对路由器通过使用 179 端口的半永久 TCP 连接交换路由选择信息。跨越两个 AS 的 BGP 连接称为**外部 BGP（eBGP）连接，而在相同 AS 中的两台路由器之间的 BGP 会话称为内部 BGP（iBGP）**连接。</p><p>两种连接如下图所示：</p><p><img src="'+u+'" alt="image-20230511173436938" loading="lazy"></p><p>BGP 会话：</p><p>两个 BGP 路由器（“对等方”）通过半永久 TCP 连接交换 BGP 消息：通告到不同目标网络前缀的路径（BGP 是一种“path vector”协议）</p><h3 id="bgp-messages" tabindex="-1"><a class="header-anchor" href="#bgp-messages" aria-hidden="true">#</a> BGP messages</h3><p>BGP messages exchanged between peers over TCP connection.</p><p>BGP messages:</p><ul><li><code>OPEN</code>: opens TCP connection to remote BGP peer(与远程 BGP 对等体) and authenticates sending BGP peer</li><li><code>UPDATE</code>: advertises new path (or withdraws old 撤回旧路径)</li><li><code>KEEPALIVE</code>: keeps connection alive in absence of <code>UPDATES</code>(没有更新的情况下); also ACKs <code>OPEN</code> request(确认打开请求)</li><li><code>NOTIFICATION</code>: reports errors in previous msg; also used to close connection</li></ul><h3 id="bgp-ospf-forwarding-table-entries" tabindex="-1"><a class="header-anchor" href="#bgp-ospf-forwarding-table-entries" aria-hidden="true">#</a> BGP, OSPF, forwarding table entries</h3><p>How does router set forwarding table entry to distant prefix?</p><p><img src="'+g+'" alt="image-20230511173842188" loading="lazy"></p><h3 id="path-attributes-and-bgp-routes" tabindex="-1"><a class="header-anchor" href="#path-attributes-and-bgp-routes" aria-hidden="true">#</a> Path attributes and BGP routes</h3><p>advertised prefix includes BGP attributes 播发的前缀其实包括 BGP 属性:</p>',34),F=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mtext",null,"prefix"),s("mo",null,"+"),s("mtext",null,"attributes"),s("mo",null,"="),s("mtext",null,"“route”")]),s("annotation",{encoding:"application/x-tex"}," \\text{prefix} + \\text{attributes} = \\text{“route”} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"prefix")]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"attributes")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord text"},[s("span",{class:"mord"},"“route”")])])])])])],-1),T=t('<p>其中 two important attributes:</p><ul><li><code>AS-PATH:</code> list of ASes through which prefix advertisement has passed</li><li><code>NEXT-HOP</code>: indicates(指示) specific internal-AS router to next-hop(下一跃点) AS</li></ul><h3 id="determining-the-best-routes" tabindex="-1"><a class="header-anchor" href="#determining-the-best-routes" aria-hidden="true">#</a> Determining the Best Routes</h3><p>通告前缀包括一些 BGP 属性（BGP attribute），前缀及其属性称为路由（route）。</p><h4 id="热土豆路由选择" tabindex="-1"><a class="header-anchor" href="#热土豆路由选择" aria-hidden="true">#</a> 热土豆路由选择</h4><p>hot potato routing</p><p>热土豆路由选择的基本思想是：<strong>对于一个路由，尽可能快地将分组送出其 AS，而不必担心其 AS 外部到目的地的余下部分的开销</strong>。</p><p>在路由器转发表中增加 AS 外部目的地的步骤：</p><p><img src="'+y+'" alt="image-20230217103850062" loading="lazy"></p><h4 id="路由选择算法" tabindex="-1"><a class="header-anchor" href="#路由选择算法" aria-hidden="true">#</a> 路由选择算法</h4><p>Route-Selection Algorithm</p><p>如果到相同前缀有两条或多条路由，则顺序地调用下列消除规则知道余下一条路由：</p><ol><li>路由被指派一个本地偏好（local preference）值作为其属性值之一，具有最高本地偏好值的将被选择；</li><li>从余下的路由中，将选择具有最短<code>AS-PATH</code>的路由；</li><li>从余下的路由中，使用热土豆路由选择，即选择具有最靠近<code>NEXT-HOP</code>路由器的路由；</li><li>如果仍留下多条路由，该路由器使用 BGP 标识符来选择路由。</li></ol><h3 id="ip-任播" tabindex="-1"><a class="header-anchor" href="#ip-任播" aria-hidden="true">#</a> IP 任播</h3><p>IP 任播的动机：</p><ol><li>在许多分散的不同地理位置，替换不同服务器上的相同内容；</li><li>让每个用户从最靠近的服务器访问内容。</li></ol><p>使用 IP 任播将用户引向最近的 CDN 服务器如下图：</p><p><img src="'+x+'" alt="image-20230218222118235" loading="lazy"></p><h3 id="路由选择策略" tabindex="-1"><a class="header-anchor" href="#路由选择策略" aria-hidden="true">#</a> 路由选择策略</h3><p>Routing Policy</p><p>如下图所示，X 是一个<strong>多宿主接入 ISP（multi-homed stub network）</strong>，因为它是经由两个不同的提供商连到网络的其余部分。</p><p><img src="'+f+'" alt="image-20230511182105569" loading="lazy"></p><ul><li>A advertises path Aw to B and to C</li><li>B <em>chooses not to advertise</em> BAw to C</li></ul><p>ISP 遵循的法则：任何穿越某 ISP 主干网的流量必须是其源或者目的位于该 ISP 的某个客户网络中；不然的话这些流量将会免费搭车通过该 ISP 的网络。</p><p>区分 AS 间和 AS 内部路由选择的原因：</p><ul><li>策略（Policy）；</li><li>规模（Scale）；</li><li>性能（Performance）；</li></ul><h2 id="the-sdn-control-plane" tabindex="-1"><a class="header-anchor" href="#the-sdn-control-plane" aria-hidden="true">#</a> The SDN control plane</h2><h3 id="software-defined-networking-sdn" tabindex="-1"><a class="header-anchor" href="#software-defined-networking-sdn" aria-hidden="true">#</a> Software defined networking (SDN)</h3><p>Internet network layer: historically has been implemented via distributed, per-router approach(历史上一直通过分布式、每路由器方法实现), and till 2005: renewed interest in rethinking network control plane(重新审视网络控制平面的兴趣)</p><p>Why a logically centralized control plane? 为什么选择逻辑集中的控制平面？</p><ul><li>更轻松的网络管理：避免路由器配置错误，提高流量灵活性</li><li>基于表的转发（回想一下 OpenFlow API）允许“编程”路由器</li><li>控制平面（control plane）的开放（非专有）实现</li></ul>',31),R={href:"https://www.ibm.com/topics/sdn",target:"_blank",rel:"noopener noreferrer"},q=s("h3",{id:"what-is-sdn",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#what-is-sdn","aria-hidden":"true"},"#"),a(" What is SDN?")],-1),j={href:"https://www.ibm.com/topics/infrastructure",target:"_blank",rel:"noopener noreferrer"},H=s("h3",{id:"why-use-sdn",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#why-use-sdn","aria-hidden":"true"},"#"),a(" Why use SDN?")],-1),W={href:"https://www.ibm.com/cloud/learn/iaas",target:"_blank",rel:"noopener noreferrer"},U=s("p",null,"SDN also increases visibility and flexibility. In a traditional environment, a router or switch—whether in the cloud or physically in the data center—is only aware of the status of network devices next to it. SDN centralizes this information so that organizations can view and control the entire network and devices. Organizations can also segment different virtual networks within a single physical network or connect different physical networks to create a single virtual network, offering a high degree of flexibility. SDN 还提高了可见性和灵活性。在传统环境中，路由器或交换机——无论是在云端还是物理上在数据中心——只知道它旁边的网络设备的状态。 SDN 集中了这些信息，以便组织可以查看和控制整个网络和设备。组织还可以在单 ​​ 个物理网络内分割不同的虚拟网络，或连接不同的物理网络以创建单个虚拟网络，从而提供高度的灵活性。",-1),X=s("p",null,"Simply put, companies are using SDN because it’s a way to efficiently control traffic and scale as needed. 简而言之，公司正在使用 SDN，因为它是一种根据需要有效控制流量和扩展的方法。",-1),K=s("p",null,"SDN 体系结构如下图所示：",-1),J=s("p",null,[s("img",{src:w,alt:"image-20230511182639115",loading:"lazy"})],-1),Q=s("p",null,"SDN 体系结构具有四个关键特征：",-1),Y=s("ul",null,[s("li",null,"基于流的转发（Flow-based forwarding）；"),s("li",null,"数据平面与控制平面分离（Separation of data plane and control plane）；"),s("li",null,"网络控制功能（Network control functions）；"),s("li",null,"可编程网络（A programmable network）。")],-1);function Z($,ss){const n=i("ExternalLinkIcon");return r(),o("div",null,[k,s("blockquote",null,[s("p",null,[a("部分内容参考自 "),s("a",b,[a("【计算机网络-自顶向下】5—Network Layer:Control Plane 网络层：控制平面（概述、路由选择算法、OSPF、BGP、SDN、ICMP、SNMP）_一棵___大树的博客-CSDN 博客"),e(n)]),a("，有删改。")])]),_,S,P,z,D,N,M,A,B,G,I,O,L,E,C,V,F,T,s("blockquote",null,[s("p",null,[s("a",R,[a("What is Software-Defined Networking? (ibm.com)"),e(n)])]),q,s("p",null,[a("SDN is an approach to networking that uses software controllers that can be driven by application programming interfaces (APIs) to communicate with hardware "),s("a",j,[a("infrastructure"),e(n)]),a(" to direct network traffic. Using software, it creates and operates a series of virtual overlay networks that work in conjunction with a physical underlay network. SDNs offer the potential to deliver application environments as code and minimize the hands-on time needed for managing the network. SDN 是一种网络方法，它使用可由应用程序编程接口 (API) 驱动的软件控制器与硬件基础设施通信以引导网络流量。它使用软件创建和运行一系列与物理底层网络协同工作的虚拟覆盖网络。 SDN 提供了将应用程序环境作为代码交付的潜力，并最大限度地减少了管理网络所需的动手时间。")]),H,s("p",null,[a("Companies today are looking to SDN to bring the benefits of the cloud to network deployment and management. With network virtualization, organizations can open the door to greater efficiency through new tools and technology, such as Software-as-a-Service (SaaS), Infrastructure-as-a-Service ("),s("a",W,[a("IaaS"),e(n)]),a(") and other cloud computing services, as well as integrate via APIs with their software-defined network. 当今的公司希望通过 SDN 将云的优势带入网络部署和管理中。借助网络虚拟化，组织可以通过软件即服务 (SaaS)、基础设施即服务 (IaaS) 和其他云计算服务等新工具和技术打开提高效率的大门，以及通过 API 与其软件定义网络集成。")]),U,X]),K,J,Q,Y])}const ts=l(v,[["render",Z],["__file","05-network-layer-2.html.vue"]]);export{ts as default};

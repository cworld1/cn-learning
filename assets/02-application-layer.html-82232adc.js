import{_ as i,M as l,p as o,q as r,R as e,t as n,N as t,a1 as a}from"./framework-9363aed8.js";const c="/assets/image-20230316170707030-0e9b4223.png",d="/assets/image-20230316180046303-ae9ac82f.png",p="/assets/v2-1455270ae0d753856037a9e432a8f79b_b-13ecf41f.jpg",u="/assets/dns_record_request_sequence_recursive_resolver-0bfac24a.png",h="/assets/dns_record_request_sequence_authoritative_nameserver-04cf3c30.png",m="/assets/what_is_a_dns_server_dns_lookup-429ca6a6.png",v="/assets/1_bjlwOQvdSYGktTtPuGVldQ-402a9324.webp",b="/assets/udp-client-server-59c3921e.png",g="/assets/7faef4a58ca97097d08c543ca6a8e9fc-e8051af0.png",k="/assets/2c25303f3be41dbd0bea218be3e2cf76-33e133c0.png",_="/assets/7e3ab650d5f1ee24023bc55e37a4a29a-880bf76c.png",f="/assets/b62fc63e9171dd10e97dc61d81acb6f8-a249ed20.png",T="/assets/5f2cf05b64d8297ddf0b5569453eda95-d8e131b5.png",P="/assets/3cfefb9eba458bfc0868b36c2b769f52-04d5c22e.png",y={},S=a('<h1 id="chapter-2-application-layer" tabindex="-1"><a class="header-anchor" href="#chapter-2-application-layer" aria-hidden="true">#</a> Chapter 2: Application Layer</h1><h2 id="outline" tabindex="-1"><a class="header-anchor" href="#outline" aria-hidden="true">#</a> Outline</h2><ol><li>principles of network applications</li><li>Web and HTTP</li><li>Electronic mail: SMTP, POP3, IMAP</li><li>DNS</li><li>P2P applications</li><li>Video streaming and content distribution networks</li><li>Socket programming with UDP and TCP</li></ol><h2 id="creating-a-network-app" tabindex="-1"><a class="header-anchor" href="#creating-a-network-app" aria-hidden="true">#</a> Creating a network app</h2><p>write programs that:</p><ul><li><p>run on (different) end systems</p></li><li><p>communicate over network</p><div class="custom-container tip"><p>e.g., web server software communicates with browser software</p></div></li></ul><p>no need to write software for network-core devices:</p><ul><li>network-core devices(网络核心设备) do not run user applications</li><li>applications on end systems(终端系统上的应用程序) allows for rapid app development, propagation(传播)</li></ul><p>结构上：</p><ul><li>client-server 服务器与客户端</li><li>peer-to-peer (P2P) 端对端</li></ul><h3 id="client-server-architecture" tabindex="-1"><a class="header-anchor" href="#client-server-architecture" aria-hidden="true">#</a> Client-server architecture</h3><p>server:</p><ul><li>always-on host(不间断主机)</li><li>permanent(永久) IP address</li><li>data centers for scaling(拓展)</li></ul><p>clients:</p><ul><li>communicate with server</li><li>may be intermittently(间歇性的) connected</li><li>may have dynamic IP addresses(动态 IP)</li><li>do not communicate directly with each other</li></ul><p><img src="'+c+'" alt="image-20230316170707030" loading="lazy"></p><h3 id="p2p-architecture" tabindex="-1"><a class="header-anchor" href="#p2p-architecture" aria-hidden="true">#</a> P2P architecture</h3><ul><li><p>no always-on server</p></li><li><p>arbitrary(任意的) end systems directly communicate</p></li><li><p>peers(对等体) request service from other peers, provide service in return to other peers</p></li><li><p>self scalability(自我弹性) – new peers bring new service capacity(容量), as well as new service demands(需求)</p></li><li><p>peers are intermittently(间歇性) connected and change IP addresses</p></li><li><p>complex(复杂的) management</p></li></ul><p><img src="'+d+'" alt="image-20230316180046303" loading="lazy"></p><h3 id="processes-communicating" tabindex="-1"><a class="header-anchor" href="#processes-communicating" aria-hidden="true">#</a> Processes communicating</h3><ul><li>client process: process that initiates communication</li><li>server process: process that waits to be contacted</li></ul><div class="custom-container tip"><p>Applications with P2P architectures have client processes &amp; server processes</p></div><h3 id="sockets" tabindex="-1"><a class="header-anchor" href="#sockets" aria-hidden="true">#</a> Sockets</h3>',23),w={href:"https://zhuanlan.zhihu.com/p/260139078",target:"_blank",rel:"noopener noreferrer"},D=e("p",null,"套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。",-1),x=e("p",null,"我们将一个小区比作一台计算机，一台计算机里面跑了很多程序，怎么区分程序呢，用的是端口，就好像小区用门牌号区分每一户人家一样。手机送到小明家了，怎么进去呢？从大门进啊，怎么找到大门呢？门牌号呀。不就相当于从互联网来的数据找到接收端计算机后再根据端口判断应该给哪一个程序一样吗。小明家的入口就可以用小区地址+门牌号进行唯一表示，那么同样的道理，程序也可以用 IP+端口号进行唯一标识。那么这个程序的入口就被称作 Socket。",-1),N=a('<p>socket analogous(很相似的) to door:</p><ul><li>sending process shoves(推送) message out door</li><li>sending process relies on transport infrastructure(基础设施) on other side of door to deliver message to socket at receiving process</li></ul><h3 id="addressing-processes" tabindex="-1"><a class="header-anchor" href="#addressing-processes" aria-hidden="true">#</a> Addressing processes</h3><p>To receive messages, process must have <strong>identifier</strong>.</p><p>identifier includes both IP address and port numbers associated with process on host.</p><h3 id="what-transport-service-does-an-app-need" tabindex="-1"><a class="header-anchor" href="#what-transport-service-does-an-app-need" aria-hidden="true">#</a> What transport service does an app need?</h3><p>data integrity(数据完整性)</p><ul><li>some apps (e.g., file transfer, web transactions) require 100% reliable data transfer</li><li>other apps (e.g., audio) can tolerate(容忍，允许) some loss</li></ul><p>timing(时效性，即时性)</p><ul><li>some apps (e.g., Internet telephony(网络电话), interactive games) require low delay to be “effective”</li></ul><p>throughput(吞吐率)</p><ul><li>some apps (e.g., multimedia) require minimum amount of throughput to be “effective”</li><li>other apps (“elastic apps”，弹性应用) make use of whatever throughput they get</li></ul><p>security(安全性)</p><ul><li>encryption, data integrity(数据完整性)</li></ul><h3 id="internet-transport-protocols-协议-services" tabindex="-1"><a class="header-anchor" href="#internet-transport-protocols-协议-services" aria-hidden="true">#</a> Internet transport protocols(协议) services</h3><p>TCP service:</p><ul><li><strong>reliable transport</strong> between sending and receiving process</li><li><strong>flow control(流量控制)</strong>: sender won’t overwhelm(溢出) receiver</li><li><strong>congestion control(拥塞控制)</strong>: throttle(限制，掐死) sender when network overloaded</li><li>does not provide: <strong>timing, minimum throughput guarantee, security</strong></li><li><strong>connection-oriented(面向连接)</strong>: setup required between client and server processes</li></ul><p>UDP service:</p><ul><li>unreliable data transfer between sending and receiving process</li><li>does not provide: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup</li></ul>',19),C={href:"https://zhuanlan.zhihu.com/p/24860273",target:"_blank",rel:"noopener noreferrer"},A=a("<p>TCP/IP 协议是一个协议簇。里面包括很多协议的，UDP 只是其中的一个，之所以命名为 TCP/IP 协议，因为 TCP、IP 协议是两个很重要的协议，就用他两命名了。</p><p>TCP/IP 协议集包括应用层，传输层，网络层，网络访问层。</p><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong></p><p>TCP 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才能建立起来。</p><p><strong>UDP（User Data Protocol，用户数据报协议）</strong></p><p>1、UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP 传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p><p>2、由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</p><p>3、UDP 信息包的标题很短，只有 8 个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。</p><p>4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</p><p>5、UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p><p>6、UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p>",11),I=a('<h3 id="securing-tcp-and-ssl" tabindex="-1"><a class="header-anchor" href="#securing-tcp-and-ssl" aria-hidden="true">#</a> Securing TCP and SSL</h3><p>TCP &amp; UDP 存在的问题：</p><ul><li>no encryption</li><li>cleartext passwds(明文密码) sent into socket traverse(通过) Internet in cleartext</li></ul><p>SSL：</p><ul><li>provides encrypted TCP connection</li><li>data integrity(数据完整性)</li><li>end-point authentication(身份验证)</li></ul><p>此外注意：</p><ul><li><p>SSL is at app layer(位于应用层): apps use SSL libraries, that “talk” to TCP</p></li><li><p>SSL socket API: cleartext passwords sent into socket traverse Internet encrypted</p></li></ul><h2 id="web-and-http" tabindex="-1"><a class="header-anchor" href="#web-and-http" aria-hidden="true">#</a> Web and HTTP</h2>',8),H={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP",target:"_blank",rel:"noopener noreferrer"},M=e("p",null,[e("strong",null,"HTTP"),n("（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在 1989-1991 年间创造出它以来，HTTP 已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP 已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和 3D 效果的现代复杂互联网协议。")],-1),E=e("h3",{id:"万维网的发明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#万维网的发明","aria-hidden":"true"},"#"),n(" 万维网的发明")],-1),q=e("p",null,[n("1989 年，当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 "),e("em",null,"Mesh"),n("，在随后的 1990 年项目实施期间被更名为万维网（World Wide Web）。它在现有的 TCP 和 IP 协议基础之上建立，由四个部分组成：")],-1),z={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML",target:"_blank",rel:"noopener noreferrer"},U=e("li",null,"一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。",-1),L=e("li",null,[n("一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 "),e("em",null,"WorldWideWeb。")],-1),W=e("li",null,[n("一个服务器用于提供可访问的文档，即 "),e("em",null,"httpd"),n(" 的前身。")],-1),R=e("p",null,"HTTP 在应用的早期阶段非常简单，后来被称为 HTTP/0.9，有时也叫做单行（one-line）协议。",-1),O=e("h3",{id:"http-0-9——单行协议",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#http-0-9——单行协议","aria-hidden":"true"},"#"),n(" HTTP/0.9——单行协议")],-1),F={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET",target:"_blank",rel:"noopener noreferrer"},G=e("code",null,"GET",-1),B=a(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /mypage.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>响应也极其简单的：只包含响应文档本身。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;HTML&gt;
这是一个非常简单的 HTML 页面
&lt;/HTML&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跟后来的版本不同，HTTP/0.9 的响应内容并不包含 HTTP 头。这意味着只有 HTML 文件可以传送，无法传输其他类型的文件。也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。</p><h3 id="http-1-0——构建可扩展性" tabindex="-1"><a class="header-anchor" href="#http-1-0——构建可扩展性" aria-hidden="true">#</a> HTTP/1.0——构建可扩展性</h3><p>由于 HTTP/0.9 协议的应用十分有限，浏览器和服务器迅速扩展内容使其用途更广：</p>`,6),K=e("li",null,[n("协议版本信息现在会随着每个请求发送（"),e("code",null,"HTTP/1.0"),n(" 被追加到了 "),e("code",null,"GET"),n(" 行）。")],-1),V=e("li",null,"状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。",-1),j=e("li",null,"引入了 HTTP 标头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。",-1),Y={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type",target:"_blank",rel:"noopener noreferrer"},Q=e("code",null,"Content-Type",-1),J=a(`<p>一个典型的请求看起来就像这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
&lt;HTML&gt;
一个包含图片的页面
  &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;
&lt;/HTML&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是第二个连接，请求获取图片（并具有相同的响应）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /myimage.gif HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:32 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/gif
(这里是图片内容)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),X={href:"https://datatracker.ietf.org/doc/html/rfc1945",target:"_blank",rel:"noopener noreferrer"},Z=e("h3",{id:"http-1-1——标准化的协议",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#http-1-1——标准化的协议","aria-hidden":"true"},"#"),n(" HTTP/1.1——标准化的协议")],-1),$=e("p",null,"HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱。自 1995 年开始，即 HTTP/1.0 文档发布的下一年，就开始修订 HTTP 的第一个标准化版本。在 1997 年初，HTTP1.1 标准发布，就在 HTTP/1.0 发布的几个月后。",-1),ee=e("p",null,"HTTP/1.1 消除了大量歧义内容并引入了多项改进：",-1),ne=e("li",null,"连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。",-1),se=e("li",null,"增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。",-1),te=e("li",null,"支持响应分块。",-1),ae=e("li",null,"引入额外的缓存控制机制。",-1),ie=e("li",null,"引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。",-1),le={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host",target:"_blank",rel:"noopener noreferrer"},oe=e("code",null,"Host",-1),re=a(`<p>一个典型的请求流程，所有请求都通过一个连接实现，看起来就像这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /en-US/docs/Glossary/Simple_header HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Wed, 20 Jul 2016 10:55:30 GMT
Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;
Keep-Alive: timeout=5, max=1000
Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
Server: Apache
Transfer-Encoding: chunked
Vary: Cookie, Accept-Encoding

(content)


GET /static/img/header-background.png HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header

200 OK
Age: 9578461
Cache-Control: public, max-age=315360000
Connection: keep-alive
Content-Length: 3077
Content-Type: image/png
Date: Thu, 31 Mar 2016 13:34:46 GMT
Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT
Server: Apache

(image content of 3077 bytes)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),ce={href:"https://datatracker.ietf.org/doc/html/rfc2068",target:"_blank",rel:"noopener noreferrer"},de={href:"https://datatracker.ietf.org/doc/html/rfc2616",target:"_blank",rel:"noopener noreferrer"},pe={href:"https://datatracker.ietf.org/doc/html/rfc7230",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://datatracker.ietf.org/doc/html/rfc7235",target:"_blank",rel:"noopener noreferrer"},he=a('<h3 id="http-overview" tabindex="-1"><a class="header-anchor" href="#http-overview" aria-hidden="true">#</a> HTTP overview</h3><p>HTTP: hypertext(超文本) transfer protocol</p><ul><li><p>Web’s application layer protocol</p></li><li><p><strong>client/server model</strong></p><ul><li>client: browser that requests, receives, (using HTTP protocol) and “displays” Web objects</li><li>server: Web server sends (using HTTP protocol) objects in response to requests</li></ul></li></ul><p>HTTP request message: ASCII (human-readable format)</p><h3 id="uploading-form-input" tabindex="-1"><a class="header-anchor" href="#uploading-form-input" aria-hidden="true">#</a> Uploading form input</h3><p>POST method:</p><ul><li>web page often includes form input</li><li>input is uploaded to server in entity(实体) body</li></ul><p>URL method:</p><ul><li><p>uses GET method</p></li><li><p>input is uploaded in URL field of request line：如 <code>www.somesite.com/animalsearch?monkeys&amp;banana</code></p></li></ul><h3 id="method-types" tabindex="-1"><a class="header-anchor" href="#method-types" aria-hidden="true">#</a> Method types</h3><p>HTTP/1.0:</p><ul><li>GET</li><li>POST</li><li>HEAD：asks server to leave requested object out of response</li></ul><p>HTTP/1.1:</p><ul><li>GET</li><li>POST</li><li>HEAD</li><li>PUT：uploads file in entity body to path specified in URL field</li><li>DELETE：deletes file specified in the URL field</li></ul><h3 id="http-response-status-codes-http-响应状态码" tabindex="-1"><a class="header-anchor" href="#http-response-status-codes-http-响应状态码" aria-hidden="true">#</a> HTTP response status codes(HTTP 响应状态码)</h3><p>status code appears in 1st line in server-to-client response message.</p>',16),me={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status",target:"_blank",rel:"noopener noreferrer"},ve={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP",target:"_blank",rel:"noopener noreferrer"},be={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E4%BF%A1%E6%81%AF%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"},ge=e("code",null,"100",-1),ke=e("code",null,"199",-1),_e={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"},fe=e("code",null,"200",-1),Te=e("code",null,"299",-1),Pe={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E9%87%8D%E5%AE%9A%E5%90%91%E6%B6%88%E6%81%AF",target:"_blank",rel:"noopener noreferrer"},ye=e("code",null,"300",-1),Se=e("code",null,"399",-1),we={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"},De=e("code",null,"400",-1),xe=e("code",null,"499",-1),Ne={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"},Ce=e("code",null,"500",-1),Ae=e("code",null,"599",-1),Ie={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E4%BF%A1%E6%81%AF%E5%93%8D%E5%BA%94",target:"_blank",rel:"noopener noreferrer"},He={href:"https://learn.microsoft.com/zh-cn/gaming/playfab/api-references/http-response-status-codes",target:"_blank",rel:"noopener noreferrer"},Me=a('<p>常见的相应状态码：</p><table><thead><tr><th style="text-align:left;">HTTP status code</th><th style="text-align:left;">General description</th></tr></thead><tbody><tr><td style="text-align:left;">100</td><td style="text-align:left;">Continue: Returned on HEAD requests</td></tr><tr><td style="text-align:left;"><strong>200</strong></td><td style="text-align:left;">OK: Returned for all successful requests. May indicate partial success for bulk APIs.</td></tr><tr><td style="text-align:left;">201</td><td style="text-align:left;">Created: Request was successful and resource was created.</td></tr><tr><td style="text-align:left;">202</td><td style="text-align:left;">Accepted: Request was successful, processing will continue asynchronously.</td></tr><tr><td style="text-align:left;">204</td><td style="text-align:left;">No Content: API successful, but there is no response to be returned from the API.</td></tr><tr><td style="text-align:left;"><strong>301</strong></td><td style="text-align:left;">Moved Permanently: requested object moved, new location specified later in this msg (Location:)</td></tr><tr><td style="text-align:left;"><strong>400</strong></td><td style="text-align:left;">Bad Request: Parameters in request where invalid or request payload structure was invalid. Do not retry.</td></tr><tr><td style="text-align:left;">401</td><td style="text-align:left;">Unauthorized: Caller is not authorized to either call the specific API or perform the action requested. Do not retry.</td></tr><tr><td style="text-align:left;">403</td><td style="text-align:left;">Forbidden: Caller is not allowed access. Do not retry.</td></tr><tr><td style="text-align:left;"><strong>404</strong></td><td style="text-align:left;">Not Found: API does not exist. Do not retry.</td></tr><tr><td style="text-align:left;">408</td><td style="text-align:left;">Request Timeout: The request took too long to be sent to the server. Okay to retry using exponential backoff pattern.</td></tr><tr><td style="text-align:left;">409</td><td style="text-align:left;">Conflict: A concurrency error occurred between two API calls. Okay to retry using exponential backoff pattern.</td></tr><tr><td style="text-align:left;">413</td><td style="text-align:left;">Payload Too Large: The request is larger than the server is allowed to handle. Do not retry. If unexpected, contact support.</td></tr><tr><td style="text-align:left;">414</td><td style="text-align:left;">URI Too Long: The URI in the request is longer than the server is allowed to handle. Do not retry.</td></tr><tr><td style="text-align:left;">429</td><td style="text-align:left;">Too Many Requests: API calls are being rate limited. Pause and then retry request, check if API returned “Retry-After” header or retryAfter in JSON response for delay needed.</td></tr><tr><td style="text-align:left;">500</td><td style="text-align:left;">Internal Server Error: An error occurred on the PlayFab server. Okay to retry, contact support if problem persists.</td></tr><tr><td style="text-align:left;">501</td><td style="text-align:left;">Not Implemented: The API called has not been implemented yet. Do not retry.</td></tr><tr><td style="text-align:left;">502</td><td style="text-align:left;">Bad Gateway: PlayFab API servers are not available to process the request. Pause and then retry request using exponential backoff pattern.</td></tr><tr><td style="text-align:left;">503</td><td style="text-align:left;">Service Unavailable: PlayFab API servers are not available to process the request. Pause and then retry request using exponential backoff pattern.</td></tr><tr><td style="text-align:left;">504</td><td style="text-align:left;">Gateway Timeout: PlayFab API servers are not available to process the request. Pause and then retry request.</td></tr><tr><td style="text-align:left;"><strong>505</strong></td><td style="text-align:left;">HTTP Version Not Supported</td></tr></tbody></table>',2),Ee=a('<h3 id="user-server-state-cookies" tabindex="-1"><a class="header-anchor" href="#user-server-state-cookies" aria-hidden="true">#</a> User-server state: cookies</h3><p>many Web sites use cookies</p><p><em>four components:</em></p><ol><li>cookie header line of HTTP <em>response</em> message</li><li>cookie header line in next HTTP <em>request</em> message</li><li>cookie file kept on user’s host, managed by user’s browser</li><li>back-end database at Web site</li></ol><p>what cookies can be used for:</p><ul><li>authorization</li><li>shopping carts(购物车，也代指其他需要存储的东西)</li><li>recommendations</li><li>user session state (Web e-mail)</li></ul><h3 id="web-caches-proxy-server" tabindex="-1"><a class="header-anchor" href="#web-caches-proxy-server" aria-hidden="true">#</a> Web caches (proxy server)</h3><ul><li><p>user sets browser: Web accesses via cache</p></li><li><p>browser sends all HTTP requests to cache</p><p>object in cache: cache returns object else <strong>cache</strong> requests object from origin server, then returns object to client</p></li></ul><p>Web 缓存（也称为代理服务器）是广泛用于提高 Web 页面加载速度和减轻网络流量压力的技术。它的工作方式是在用户和 Web 服务器之间放置一个位于网络边缘的服务器，该服务器存储先前获取的 Web 页面的副本，以便当后续用户请求相同页面时，可以直接返回本地存储的副本，而不必重新从源服务器下载。这样，用户就可以更快地加载页面，并且减轻了源服务器的压力。</p><p>Web 缓存可以根据不同的应用场景进行配置，例如在企业内部网络中设置私有 Web 缓存来提高内部网站的访问速度，或在 Internet 网络边缘设置公共 Web 缓存来减轻互联网上的流量压力。此外，Web 缓存还可以通过缓存一些常用的 JavaScript 和 CSS 文件等静态资源，来进一步提高页面加载速度。</p><p>需要注意的是，Web 缓存不适用于动态生成的 Web 页面或需要个性化处理的页面，因为这些页面的内容是根据用户请求动态生成的，所以不可能事先缓存下来。此外，一些受保护的 Web 页面（如登录页）也不能缓存，因为每个用户的页面内容都是不同的，不适合缓存下来供其他用户使用。</p><h3 id="conditional-get" tabindex="-1"><a class="header-anchor" href="#conditional-get" aria-hidden="true">#</a> Conditional GET</h3><p>Conditional GET 是一个 HTTP 协议的特性，可以在客户端像服务器发起请求时，通过发送 HTTP 头部中的条件标识，让服务器判断资源是否发生了变化，如果资源未发生变化，服务器可以选择不返回资源实体，而是返回 304 Not Modified 状态码，从而节省网络带宽和服务器资源。</p><p>使用条件 GET 时，客户端发送的请求中会包含 If-Modified-Since、If-Unmodified-Since、If-Match、If-None-Match 等条件标识，这些条件标识指定了客户端请求的资源应该满足的条件。当服务器对客户端的请求进行处理时，会根据这些条件是否满足来决定是否返回实际的资源，或者只返回 304 状态码。</p><p>条件 GET 可以提高网络传输效率和响应速度，因为服务器避免了重复发送已经有缓存的资源，从而降低了网络带宽的消耗。</p><h2 id="electronic-mail" tabindex="-1"><a class="header-anchor" href="#electronic-mail" aria-hidden="true">#</a> Electronic Mail</h2>',16),qe={href:"https://www.geeksforgeeks.org/introduction-to-electronic-mail/",target:"_blank",rel:"noopener noreferrer"},ze=e("p",null,"Electronic mail, commonly known as email, is a method of exchanging messages over the internet.",-1),Ue=e("p",null,"Here are the basics of email:",-1),Le=e("ol",null,[e("li",null,"An email address: This is a unique identifier for each user, typically in the format of name@domain.com."),e("li",null,"An email client: This is a software program used to send, receive and manage emails, such as Gmail, Outlook, or Apple Mail."),e("li",null,"An email server: This is a computer system responsible for storing and forwarding emails to their intended recipients.")],-1),We=e("p",null,"SMTP (Simple Mail Transfer Protocol)、POP3 (Post Office Protocol Version 3) 和 IMAP (Internet Message Access Protocol) 都是在互联网上传输邮件的协议。",-1),Re=e("h3",{id:"smtp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#smtp","aria-hidden":"true"},"#"),n(" SMTP")],-1),Oe=e("p",null,"SMTP (Simple Mail Transfer Protocol [RFC 2821]): 协议不负责接收邮件，在邮件传递过程中，它只负责将邮件从发送者的邮件服务器传递到接收者的邮件服务器。SMTP 协议发送邮件的过程通常分为以下步骤：",-1),Fe=e("ol",null,[e("li",null,"发送方邮件客户端（如 Outlook 等）向发送方邮件服务器发送邮件。"),e("li",null,"发送方邮件服务器将邮件发送给接收方邮件服务器，通过 SMTP 协议与接收方邮件服务器通信，询问是否可以接收该邮件。"),e("li",null,"接收方邮件服务器回复确认，发送方邮件服务器将邮件发送给接收方邮件服务器。"),e("li",null,"接收方邮件服务器接收到邮件并存储下来，接收方在自己的邮件客户端中查看邮件。")],-1),Ge=e("p",null,"SMTP 协议的工作原理如下：",-1),Be=e("li",null,[e("p",null,"连接建立（SMTP connection opened）：发送方邮件服务器与接收方邮件服务器建立 TCP 连接（25 号端口）；握手：发送方发送 EHLO 命令告诉接收方客户端自己的域名和所支持的命令，接收方回复 250 OK 表示可以通信。")],-1),Ke=e("li",null,[e("p",null,"发送邮件数据（Email data transferred）：发送方向接收方发送邮件数据，包括邮件头和邮件正文。")],-1),Ve=e("p",null,[e("strong",null,"Mail Transfer Agent (MTA):"),n(" 在邮件传输过程中实际传送邮件的程序或服务。MTA 会负责从发件人的 SMTP 客户端接收邮件并将其传递给相应的收件人的 SMTP 服务器。MTA 还可以处理邮件发送过程中的错误或问题，例如无法传递邮件或邮件被拒绝等情况。常见的 MTA 软件包括 Sendmail、Postfix 和 Qmail 等。")],-1),je={href:"https://www.cloudflare.com/learning/email-security/what-is-smtp/",target:"_blank",rel:"noopener noreferrer"},Ye={href:"https://www.cloudflare.com/learning/dns/what-is-dns/",target:"_blank",rel:"noopener noreferrer"},Qe={href:"https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/",target:"_blank",rel:"noopener noreferrer"},Je=e("li",null,[e("p",null,"断开连接（Connection closed）：发送方发送 QUIT 命令告诉接收方已经完成发送，接收方回复 221 表示连接已断开。")],-1),Xe=e("p",null,"POP3 是一种用于接收电子邮件的协议。当您使用 POP3 协议从邮件服务器下载邮件时，邮件服务器就会将邮件传送到您的邮件客户端中，并从服务器上删除邮件。",-1),Ze=e("p",null,"IMAP 是另一种用于接收电子邮件的协议，它与 POP3 不同的是，它允许您在邮件服务器上保留邮件的副本，可以在多个设备之间同步邮件。这样，当您在一个设备上修改或删除邮件时，在其他设备上也可以看到这些修改。",-1),$e={href:"https://www.cloudflare.com/learning/email-security/what-is-smtp/",target:"_blank",rel:"noopener noreferrer"},en=a(`<p>What are SMTP commands?</p><p>SMTP commands are predefined text-based instructions that tell a client or server what to do and how to handle any accompanying data. Think of them as buttons the client can press to get the server to accept data correctly.</p><ul><li><p><code>HELO/EHLO</code>: These commands say &quot;Hello&quot; and start off the SMTP connection between client and server. &quot;<code>HELO</code>&quot; is the basic version of this command; &quot;<code>EHLO</code>&quot; is for a specialized type of SMTP.</p></li><li><p><code>MAIL FROM</code>: This tells the server who is sending the email. If Alice were trying to email her friend Bob, a client might send &quot;MAIL FROM:<a href="mailto:alice@example.com">alice@example.com</a>&quot;.</p></li><li><p><code>RCPT TO</code>: This command is for listing the email&#39;s recipients. A client can send this command multiple times if there are multiple recipients. In the example above, Alice&#39;s email client would send &quot;RCPT TO:<a href="mailto:bob@example.com">bob@example.com</a>&quot;.</p></li><li><p><code>DATA</code>: This precedes the content of the email.</p><p>It obeys RFC 822: standard for text message format. Like:</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>DATA
Date: Mon, 4 April 2022
From: Alice alice@example.com
Subject: Eggs benedict casserole
To: Bob bob@example.com

Hi Bob,
I will bring the eggs benedict casserole recipe on Friday.
-Alice
.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Pay attention to line 6 and line 10.</p><ul><li><code>RSET</code>: This command resets the connection, removing all previously transferred information <strong>without closing the SMTP connection</strong>. <code>RSET</code> is used if the client sent incorrect information.</li><li><code>QUIT</code>: This ends the connection.</li></ul>`,6),nn=a('<ul><li>SMTP uses persistent(持续的，可持续的) connections</li><li>SMTP requires message (header &amp; body) to be in 7-bit ASCII</li><li>SMTP server uses <strong>CRLF.CRLF</strong>(就是指一个点) to determine end of message</li></ul><p>comparison with HTTP:</p><ul><li>HTTP: pull</li><li>SMTP: push</li></ul><h3 id="pop" tabindex="-1"><a class="header-anchor" href="#pop" aria-hidden="true">#</a> POP</h3><p>POP (Post Office Protocol [RFC 1939]): authorization, download.</p><p>而 POP3 是一种用于接收电子邮件的协议。当您使用 POP3 协议从邮件服务器下载邮件时，邮件服务器就会将邮件传送到您的邮件客户端中，并从服务器上删除邮件。</p><h3 id="imap" tabindex="-1"><a class="header-anchor" href="#imap" aria-hidden="true">#</a> IMAP</h3><p>IMAP: Internet Mail Access Protocol [RFC 1730]: more features, including manipulation of stored messages on server.</p><p>IMAP 是另一种用于接收电子邮件的协议，它与 POP3 不同的是，它允许您在邮件服务器上保留邮件的副本（§keeps all messages in one place: at server），可以在多个设备之间同步邮件。这样，当您在一个设备上修改或删除邮件时，在其他设备上也可以看到这些修改。此外还有 allows user to organize messages in folders。</p><h2 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h2><h3 id="什么是-dns" tabindex="-1"><a class="header-anchor" href="#什么是-dns" aria-hidden="true">#</a> 什么是 DNS</h3>',11),sn={href:"https://zhuanlan.zhihu.com/p/186028919",target:"_blank",rel:"noopener noreferrer"},tn=a('<h3 id="dns-出现及演化" tabindex="-1"><a class="header-anchor" href="#dns-出现及演化" aria-hidden="true">#</a> DNS 出现及演化</h3><p>网络出现的早期 是使用 IP 地址通讯的，那时就几台主机通讯。但是随着接入网络主机的增多，这种数字标识的地址非常不便于记忆，UNIX 上就出现了建立一个叫做 hosts 的文件 （Linux 和 Windows 也继承保留了这个文件）。这个文件中记录这主机名称和 IP 地址的对应表。这样只要输入主机名称，系统就会去加载 hosts 文件并查找对应关系，找到对应的 IP，就可以访问这个 IP 的主机了。</p><p>但是后来主机太多了，无法保证所有人都能拿到统一的最新的 hosts 文件，就出现了在文件服务器上集中存放 hosts 文件，以供下载使用。互联网规模进一步扩大，这种方式也不堪负重，而且把所有地址解析记录形成的文件都同步到所有的客户机似乎也不是一个好办法。这时 DNS 系统出现了，随着解析规模的继续扩大，DNS 系统也在不断的演化，直到现今的多层架构体系。</p><h3 id="dns-概括" tabindex="-1"><a class="header-anchor" href="#dns-概括" aria-hidden="true">#</a> DNS 概括</h3><p>DNS（Domain Name System，域名系统），因特网上作为域名和 IP 地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最终得到该主机对应的 IP 地址的过程叫做域名解析（或主机名解析）。DNS 协议运行在 UDP 协议之上，使用端口号 53。</p><p>DNS 的分布数据库是以域名为索引的，每个域名实际上就是一棵很大的逆向树中路径，这棵逆向树称为域名空间（domain name space），如下图所示树的最大深度不得超过 127 层，树中每个节点都有一个可以长达 63 个字符的文本标号。</p><h3 id="dns-的作用" tabindex="-1"><a class="header-anchor" href="#dns-的作用" aria-hidden="true">#</a> DNS 的作用</h3><ul><li>正向解析：根据主机名称（域名）查找对应的 IP 地址</li><li>反向解析：根据 IP 地址查找对应的主机域名</li></ul><p>DNS 系统的分布式数据结构：</p><p><img src="'+p+'" alt="img" loading="lazy"></p>',10),an=e("h3",{id:"dns-相关服务器及实现",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dns-相关服务器及实现","aria-hidden":"true"},"#"),n(" DNS 相关服务器及实现")],-1),ln={href:"https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/",target:"_blank",rel:"noopener noreferrer"},on=e("h3",{id:"加载网页涉及-4-个-dns-服务器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#加载网页涉及-4-个-dns-服务器","aria-hidden":"true"},"#"),n(" 加载网页涉及 4 个 DNS 服务器")],-1),rn={href:"https://www.cloudflare.com/learning/dns/dns-server-types#recursive-resolver",target:"_blank",rel:"noopener noreferrer"},cn={href:"https://www.cloudflare.com/learning/dns/glossary/dns-root-server/",target:"_blank",rel:"noopener noreferrer"},dn={href:"https://www.cloudflare.com/learning/dns/dns-server-types#tld-nameserver",target:"_blank",rel:"noopener noreferrer"},pn={href:"https://www.cloudflare.com/learning/dns/top-level-domain/",target:"_blank",rel:"noopener noreferrer"},un={href:"https://www.cloudflare.com/learning/dns/dns-server-types#authoritative-nameserver",target:"_blank",rel:"noopener noreferrer"},hn=e("h3",{id:"权威性-dns-服务器与递归-dns-解析器之间的区别是什么",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#权威性-dns-服务器与递归-dns-解析器之间的区别是什么","aria-hidden":"true"},"#"),n(" 权威性 DNS 服务器与递归 DNS 解析器之间的区别是什么？")],-1),mn={href:"https://www.cloudflare.com/learning/dns/what-is-recursive-dns/",target:"_blank",rel:"noopener noreferrer"},vn=e("h4",{id:"递归-dns-解析器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#递归-dns-解析器","aria-hidden":"true"},"#"),n(" 递归 DNS 解析器")],-1),bn={href:"https://www.cloudflare.com/learning/dns/dns-records/",target:"_blank",rel:"noopener noreferrer"},gn={href:"https://www.cloudflare.com/learning/cdn/what-is-caching/",target:"_blank",rel:"noopener noreferrer"},kn=a('<p><img src="'+u+'" alt="DNS 记录请求序列 - DNS 递归解析器从客户端获取请求" loading="lazy"></p><h4 id="权威性-dns-服务器" tabindex="-1"><a class="header-anchor" href="#权威性-dns-服务器" aria-hidden="true">#</a> 权威性 DNS 服务器</h4><p>简言之，权威性 DNS 服务器是实际持有并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，其将使用所查询的资源记录进行响应，从而最终允许发出请求的 Web 浏览器达到访问网站或其他 Web 资源所需的 IP 地址。权威性域名服务器从自身数据满足查询需求，无需查询其他来源，因为这是某些 DNS 记录的最终真实来源。</p><p><img src="'+h+'" alt="DNS 记录请求序列 - DNS 查询到达 cloudflare.com 的权威性域名服务器" loading="lazy"></p><h3 id="dns-查找的-8-个步骤" tabindex="-1"><a class="header-anchor" href="#dns-查找的-8-个步骤" aria-hidden="true">#</a> DNS 查找的 8 个步骤</h3>',5),_n=a("<li><p>用户在 Web 浏览器中键入 “example.com”，查询传输到 Internet 中，并被 DNS 递归解析器接收。</p></li><li><p>接着，解析器查询 DNS 根域名服务器（.）。</p></li><li><p>然后，根服务器使用存储其域信息的顶级域（TLD）DNS 服务器（例如 .com 或 .net）的地址响应该解析器。在搜索 example.com 时，我们的请求指向 .com TLD。</p></li><li><p>然后，解析器向 .com TLD 发出请求。</p></li><li><p>TLD 服务器随后使用该域的域名服务器 example.com 的 IP 地址进行响应。</p></li><li><p>最后，递归解析器将查询发送到域的域名服务器。</p></li><li><p>example.com 的 IP 地址而后从域名服务器返回解析器。</p></li><li><p>然后 DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。</p></li><li><p>DNS 查找的这 8 个步骤返回 example.com 的 IP 地址后，浏览器便能发出对该网页的请求：</p></li>",9),fn={href:"https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/",target:"_blank",rel:"noopener noreferrer"},Tn=e("li",null,[e("p",null,"位于该 IP 的服务器返回将在浏览器中呈现的网页（第 10 步）。")],-1),Pn=e("p",null,[e("img",{src:m,alt:"完整的 DNS 查询和网页查询 - 10 个步骤",loading:"lazy"})],-1),yn=e("h3",{id:"什么是-dns-高速缓存-dns-高速缓存发生在哪里",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#什么是-dns-高速缓存-dns-高速缓存发生在哪里","aria-hidden":"true"},"#"),n(" 什么是 DNS 高速缓存？DNS 高速缓存发生在哪里？")],-1),Sn={href:"https://www.cloudflare.com/learning/cdn/glossary/time-to-live-ttl/",target:"_blank",rel:"noopener noreferrer"},wn=e("h4",{id:"浏览器-dns-缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#浏览器-dns-缓存","aria-hidden":"true"},"#"),n(" 浏览器 DNS 缓存")],-1),Dn=e("p",null,"现代 Web 浏览器设计为默认将 DNS 记录缓存一段时间。目的很明显；越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出正确请求而必须采取的处理步骤就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。",-1),xn=e("p",null,"在 Chrome 浏览器中，您可以转到 chrome://net-internals/#dns 查看 DNS 缓存的状态。",-1),Nn=e("h4",{id:"操作系统-os-级-dns-缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#操作系统-os-级-dns-缓存","aria-hidden":"true"},"#"),n(" 操作系统（OS）级 DNS 缓存")],-1),Cn=e("p",null,"操作系统级 DNS 解析器是 DNS 查询离开您计算机前的第二站，也是本地最后一站。操作系统内旨在处理此查询的过程通常称为“存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 Internet 服务提供商（ISP）内部的 DNS 递归解析器。",-1),An=e("p",null,"与先前所有步骤一样，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中。",-1),In=e("p",null,"根据其缓存中具有的记录类型，递归解析器还具有其他功能：",-1),Hn={href:"https://www.cloudflare.com/learning/dns/dns-records/dns-a-record/",target:"_blank",rel:"noopener noreferrer"},Mn={href:"https://www.cloudflare.com/learning/dns/dns-records/dns-ns-record/",target:"_blank",rel:"noopener noreferrer"},En=e("li",null,"如果解析器没有 NS 记录，它会向 TLD 服务器（本例中为 .com）发送查询，从而跳过根服务器。",-1),qn=e("li",null,"万一解析器没有指向 TLD 服务器的记录，其将查询根服务器。这种情况通常在清除了 DNS 高速缓存后发生。",-1),zn=e("h3",{id:"dns-records",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dns-records","aria-hidden":"true"},"#"),n(" DNS Records")],-1),Un={href:"https://www.cloudflare.com/zh-cn/learning/dns/dns-records/",target:"_blank",rel:"noopener noreferrer"},Ln={href:"https://www.cloudflare.com/learning/dns/what-is-dns/",target:"_blank",rel:"noopener noreferrer"},Wn={href:"https://www.cloudflare.com/learning/dns/dns-server-types/",target:"_blank",rel:"noopener noreferrer"},Rn={href:"https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/",target:"_blank",rel:"noopener noreferrer"},On={href:"https://www.cloudflare.com/learning/cdn/glossary/time-to-live-ttl/",target:"_blank",rel:"noopener noreferrer"},Fn=a("<p>最常见的 DNS 记录有：</p><ul><li><strong>A 记录</strong>：保存域的 IP 地址的记录。</li><li><strong>AAAA 记录</strong>：包含域的 IPv6 地址的记录（与 A 记录相反，A 记录列出的是 IPv4 地址）。</li><li><strong>CNAME 记录</strong>：将一个域或子域转发到另一个域，不提供 IP 地址。</li><li><strong>MX 记录</strong>：将邮件定向到电子邮件服务器。</li><li><strong>TXT 记录</strong>：可让管理员在记录中存储文本注释。这些记录通常用于电子邮件安全。</li><li><strong>NS 记录</strong>：存储 DNS 条目的名称服务器。</li><li><strong>SOA 记录</strong>：存储域的管理信息。</li><li><strong>SRV 记录</strong>：指定用于特定服务的端口。</li><li><strong>PTR 记录</strong>：在反向查询中提供域名。</li></ul>",2),Gn=a('<h2 id="p2p-applications-不重要" tabindex="-1"><a class="header-anchor" href="#p2p-applications-不重要" aria-hidden="true">#</a> P2P Applications（不重要）</h2><h3 id="pure-p2p-architecture-体系结构" tabindex="-1"><a class="header-anchor" href="#pure-p2p-architecture-体系结构" aria-hidden="true">#</a> Pure P2P architecture(体系结构)</h3><ul><li>no always-on server</li><li>arbitrary(任意的) end systems directly communicate(直接通信)</li><li>peers(原叫同龄人，这里指对等端) are intermittently connected and change IP addresses</li></ul><h2 id="video-streaming-and-content-distribution-networks-cdns-不重要" tabindex="-1"><a class="header-anchor" href="#video-streaming-and-content-distribution-networks-cdns-不重要" aria-hidden="true">#</a> Video streaming and content distribution networks (CDNs)（不重要）</h2><h3 id="video-traffic" tabindex="-1"><a class="header-anchor" href="#video-traffic" aria-hidden="true">#</a> Video traffic</h3><p>Video traffic: major consumer of Internet bandwidth</p><p>solution: distributed, application-level infrastructure(分布式应用程序级基础架构)</p><ul><li><p>CBR（恒定比特率）是指视频编码时采用固定的比特率来保证视频的一致性和稳定性，不论视频场景中的运动、细节、色彩变化等情况如何。因此，CBR 编码方式适用于要求视频画质和大小都相同的场合，比如直播、视频会议等。</p></li><li><p>VBR（可变比特率）是指视频编码时采用动态的比特率来实现更高的压缩效率和更好的视觉质量，它根据不同的场景自适应地改变编码比特率，达到了优化视频质量和压缩比的平衡。因此，VBR 编码方式适用于对视频质量要求高，但视频大小不是首要考虑因素的场合，比如电影、高清视频等。</p></li></ul><p>如：</p><ul><li>MPEG 1 (CD-ROM) 1.5 Mbps</li><li>MPEG 2 (DVD) 3-6 Mbps</li><li>MPEG 4 (often used in Internet, &lt; 1 Mbps)</li></ul><h3 id="streaming-multimedia-dash" tabindex="-1"><a class="header-anchor" href="#streaming-multimedia-dash" aria-hidden="true">#</a> Streaming multimedia: DASH</h3><p>DASH（Dynamic, Adaptive Streaming over HTTP）即动态自适应流式传输协议，是一种通过互联网以 HTTP 协议传输音视频内容的方法。DASH 协议允许在不同的网络环境下自动调整音视频的码率和分辨率，以保证用户可以获得最佳的观看体验。简而言之，DASH 协议可以根据用户的网络环境和设备性能自动选择最适合的视频质量，以确保视频的流畅播放和高质量观看。</p><h3 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn" aria-hidden="true">#</a> CDN</h3><p>CDN(Content Distribution Networks) 即内容分发网络，是一种在网络边缘部署节点的技术，通过靠近用户的部署位置，提高用户访问网站内容的速度和质量。以下是 CDN 的相关知识点：</p><ol><li><p>CDN 的工作原理：CDN 通过将原始服务器上的内容缓存到分布在全球各地的服务器节点上，使用户请求能够从离用户最近的服务器节点获取内容，从而提高用户访问速度和性能。</p></li><li><p>CDN 的好处：CDN 可以帮助网站提高用户访问速度、减少带宽成本、提高网站的可用性、减轻服务器负载等。</p></li><li><p>CDN 的部署方式：CDN 可以采用两种部署方式，即自建 CDN 和使用第三方 CDN。自建 CDN 需要投入大量的资金和技术力量，而使用第三方 CDN 的成本较低，但需要考虑接入成本和服务质量等问题。</p></li><li><p>CDN 的缓存方式：CDN 缓存方式可以分为边缘缓存和中心缓存两种。边缘缓存是将内容缓存到离用户最近的服务器节点上，中心缓存是将内容缓存到核心节点上，然后由核心节点向各个边缘节点分发。</p></li><li><p>CDN 的工作流程：CDN 的工作流程可以分为 DNS 解析、请求路由、内容缓存和内容传输四个阶段。DNS 解析负责将用户请求路由到最佳的 CDN 节点，请求路由将请求分发到最近的边缘节点上，内容缓存负责将内容存储到缓存中，内容传输将缓存内容传输给用户。</p></li></ol><h2 id="socket-programming-with-udp-and-tcp" tabindex="-1"><a class="header-anchor" href="#socket-programming-with-udp-and-tcp" aria-hidden="true">#</a> Socket programming with UDP and TCP</h2><p>网络协议由三个要素组成，分别是语义、语法和时序。</p><ul><li>语义是解释控制信息每个部分的含义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应；</li><li>语法是用户数据与控制信息的结构与格式，以及数据出现的顺序；</li><li>时序是对事件发生顺序的详细说明。</li></ul><p>人们形象地将这三个要素描述为：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h3 id="socket-programming" tabindex="-1"><a class="header-anchor" href="#socket-programming" aria-hidden="true">#</a> Socket programming</h3><p>Goal: learn how to build client/server applications that communicate using sockets.</p><p>Two socket types for two transport services:</p><ul><li>UDP: unreliable datagram(数据报文，数据包)</li><li>TCP: reliable, byte stream-oriented(以流为导向)</li></ul>',23),Bn={href:"https://blog.devgenius.io/building-tcp-and-udp-client-server-interactions-eb8228644da2",target:"_blank",rel:"noopener noreferrer"},Kn=e("p",null,[e("img",{src:v,alt:"1_bjlwOQvdSYGktTtPuGVldQ",loading:"lazy"})],-1),Vn=e("p",null,"This photo is a great visual representation of what is going on between the server and the client. In a Connection-oriented system, the server and client send these SYN, SYN-ACK and ACK messages to ensure the packet is successfully received, if this pattern(模式) is broken (i.e. one of these is not sent) then the packet can be re-sent.",-1),jn=e("h3",{id:"udp-与-tcp-比较",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#udp-与-tcp-比较","aria-hidden":"true"},"#"),n(" UDP 与 TCP 比较")],-1),Yn={href:"https://www.cnblogs.com/ichunqiu/p/9200723.html",target:"_blank",rel:"noopener noreferrer"},Qn=a("<p>为了更直观地比较 TCP 与 UDP 的异同，笔者将其整理成以下表格：</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接模式</td><td>面向连接（单点通信）</td><td>无连接（多点通信）</td></tr><tr><td>传输可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>通信模式</td><td>基于字节流</td><td>基于数据报</td></tr><tr><td>报头结构</td><td>复杂（至少 20 字节）</td><td>简单（8 字节）</td></tr><tr><td>传输速度</td><td>慢</td><td>快</td></tr><tr><td>资源需求</td><td>多</td><td>少</td></tr><tr><td>到达顺序</td><td>保证</td><td>不保证</td></tr><tr><td>流量控制</td><td>有</td><td>无</td></tr><tr><td>拥塞控制</td><td>有</td><td>无</td></tr><tr><td>应用场合</td><td>大量数据传输</td><td>少量数据传输</td></tr><tr><td>支持的应用层协议</td><td>Telnet、FTP、SMTP、HTTP</td><td>DNS、DHCP、TFTP、SNMP</td></tr></tbody></table>",2),Jn=e("h3",{id:"client-server-socket-udp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#client-server-socket-udp","aria-hidden":"true"},"#"),n(" Client/server socket: UDP")],-1),Xn=e("p",null,"Properties of UDP:",-1),Zn={href:"https://pythontic.com/modules/socket/udp-client-server-example",target:"_blank",rel:"noopener noreferrer"},$n=a('<ul><li>The UDP does not provide guaranteed(放心的，可靠的) delivery of message packets. If for some issue in a network if a packet is lost it could be lost <strong>forever</strong>.</li><li>Since there is no guarantee of assured(有把握的) delivery of messages, UDP is considered an unreliable protocol.</li><li>The underlying mechanisms(底层机制) that implement(实现) UDP involve <strong>no connection-based communication</strong>. There is no streaming of data between a UDP server or and an UDP Client.</li><li>An UDP client can send &quot;n&quot; number of distinct packets to an UDP server and it could also receive &quot;n&quot; number of distinct packets as replies from the UDP server.</li><li>Since UDP is connectionless protocol the overhead(负载，开销) involved in UDP is <strong>less</strong> compared to a connection based protocol like TCP.</li></ul><p><img src="'+b+'" alt="UDP Client Server Communication" loading="lazy"></p>',2),es=e("p",null,"UDP 具体实现：",-1),ns={href:"https://blog.csdn.net/phoenixFlyzzz/article/details/129790340",target:"_blank",rel:"noopener noreferrer"},ss=a('<p>面向无连接型：无需对端是否存在，发送端可随时发送数据</p><p>特点：无连接，资源开销小，传输速度快，每个数据包最大是 64k，适用于广播应用</p><p>缺陷：传输数据不可靠，容易丢包；没有流量控制，需要接收方及时接收数据，否则会写满缓冲区</p><h3 id="udp-网络流程" tabindex="-1"><a class="header-anchor" href="#udp-网络流程" aria-hidden="true">#</a> UDP 网络流程</h3><p><img src="'+g+`" alt="img" loading="lazy"></p><ol><li>保证 UPD 服务端的正常启动，进入到 recvfrom() 模式，阻塞等到客户端发送数据</li><li>开启 UDP 客户端，校准 IP 地址，通过 sendto() 模块进行数据发送</li><li>当服务端接收到接收到客户端发送来的数据，进行数据处理，并将应答数据发送给客户端</li><li>客户端接收到应答数据，可进行数据处理或重复发送数据，也可退出进程</li></ol><h3 id="udp-serve-服务端" tabindex="-1"><a class="header-anchor" href="#udp-serve-服务端" aria-hidden="true">#</a> UDP Serve 服务端</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># coding=utf-8</span>
<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>

<span class="token comment"># 1. 创建套接字</span>
udp_socket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span>

<span class="token comment"># 2. 绑定本地的相关信息，如果一个网络程序不绑定，系统会随机分配</span>
<span class="token comment">#    ip地址和端口号，如果不指明ip，则表示本机的任何一个ip</span>
<span class="token comment">#    如果不指明端口号，则每次启动都是随机生成端口号</span>
local_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span>
udp_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>local_addr<span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token comment"># 3. 阻塞等待接收对方发送的信息</span>
    <span class="token comment">#    1024表示本次接收的最大字节数</span>
    recv_data <span class="token operator">=</span> udp_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>

    <span class="token comment"># 4. 显示接收到的数据，并解码为gbk</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>recv_data<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>recv_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 5. 发送应答信息</span>
    <span class="token comment"># ip_addr = recv_data[1][0]</span>
    <span class="token comment"># port = recv_data[1][1]</span>
    addr <span class="token operator">=</span> recv_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    data <span class="token operator">=</span> <span class="token string">&#39;信息已收到&#39;</span>
    udp_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>

udp_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="udp-client-客户端" tabindex="-1"><a class="header-anchor" href="#udp-client-客户端" aria-hidden="true">#</a> UDP Client 客户端</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> socket

<span class="token comment"># 1. 创建upd套接字</span>
udp_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span>

<span class="token comment"># 2. 准备服务端地址与端口号</span>
<span class="token comment">#   127.0.0.1 代表自身ip地址，可向自身发送信息，也可指定ip地址发送信息</span>
<span class="token comment">#   端口号随便填写一个未被占用的端口即可</span>
<span class="token comment">#   Linux环境有65535个端口号，前1024个端口号是系统端口号，系统端口号不能直接使用</span>
addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;127.0.0.1&#39;</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token comment"># 3. 从键盘获取数据</span>
    data <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;请输入信息：&#39;</span><span class="token punctuation">)</span>

    <span class="token comment"># 4. 通过sendto()发送信息到指定进程中</span>
    udp_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>

    <span class="token comment"># 5. 通过recvfrom()阻塞等待获取应答数据</span>
    recv_data <span class="token operator">=</span> udp_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>

    <span class="token comment"># 6. 处理应答数据，进行打印</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>recv_data<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>recv_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

udp_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：（先运行服务端，再运行客户端）</p><p><img src="`+k+'" alt="img" loading="lazy"></p>',12),ts=e("h3",{id:"client-server-socket-tcp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#client-server-socket-tcp","aria-hidden":"true"},"#"),n(" Client/server socket: TCP")],-1),as={href:"https://blog.csdn.net/phoenixFlyzzz/article/details/129790340",target:"_blank",rel:"noopener noreferrer"},is=a('<p>面向有连接型：双方先建立连接才能进行数据传输</p><p>特点：</p><ul><li><p>双方都必须为该连接分配系统内核资源</p></li><li><p>完成数据交换后，双方必须断开连接，以释放系统资源</p></li><li><p>这种连接是一对一的，不适用于广播应用</p></li><li><p>TCP 提供可靠的数据传输，无差别、不丢失、不重复，且按序到达</p></li><li><p>相比于 UPD，TCP 数据传输速度慢、对系统资源要求较高</p></li><li><p>TCP 适合发送大量数据，UDP 适合发送少量数据</p></li><li><p>TCP 有流量控制，UPD 无流量控制</p></li></ul><h3 id="tcp-网络流程" tabindex="-1"><a class="header-anchor" href="#tcp-网络流程" aria-hidden="true">#</a> TCP 网络流程</h3><p><img src="'+_+`" alt="img" loading="lazy"></p><h3 id="tcp-serve-服务端" tabindex="-1"><a class="header-anchor" href="#tcp-serve-服务端" aria-hidden="true">#</a> TCP Serve 服务端</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span>

<span class="token comment"># 1. 创建tcp套接字</span>
tcp_serve_socket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>

<span class="token comment"># 2. 设置socket选项，程序退出后，端口会自动释放</span>
tcp_serve_socket<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 本地信息，第二个为端口</span>
addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token number">12345</span><span class="token punctuation">)</span>

<span class="token comment"># 4. 绑定地址</span>
tcp_serve_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>

<span class="token comment"># 5. 设置监听</span>
<span class="token comment">#    使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的</span>
<span class="token comment">#    参数代表等待连接时间最多60秒</span>
tcp_serve_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span>

<span class="token comment"># 6. 如果有新的客户端来连接服务，就产生一个新的套接字，专门为这个客户端服务</span>
<span class="token comment">#    client_socket用来为这个客户端服务</span>
<span class="token comment">#    原来的tcp_serve_socket就可以专门用来等待其他新用户的连接</span>
client_socket<span class="token punctuation">,</span> client_addr <span class="token operator">=</span> tcp_serve_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 7. 阻塞等待客户端发送的信息</span>
recv_data <span class="token operator">=</span> client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;接收到信息：&quot;</span><span class="token punctuation">,</span> recv_data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">&#39;gbk&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 8. 发送应答信息</span>
string <span class="token operator">=</span> <span class="token string">&#39;已收到信息&#39;</span>
client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>string<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&#39;gbk&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="tcp-client-客户端" tabindex="-1"><a class="header-anchor" href="#tcp-client-客户端" aria-hidden="true">#</a> TCP Client 客户端</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> socket

<span class="token comment"># 1. 创建TCP的套接字</span>
tcp_client_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>

<span class="token comment"># 2. 目标ip信息</span>
ip <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;请输入服务端ip：&#39;</span><span class="token punctuation">)</span>
port <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;请输入服务端port：&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 连接服务器</span>
tcp_client_socket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 4. 提示用户输入数据</span>
data <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&#39;请输入要发送的信息：&#39;</span><span class="token punctuation">)</span>

<span class="token comment"># 5. 编码</span>
tcp_client_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&#39;gbk&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 6. 接收服务端的应答数据</span>
recv_data <span class="token operator">=</span> tcp_client_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&#39;收到应答数据：&#39;</span><span class="token punctuation">,</span> recv_data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">&#39;gbk&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 7. 关闭套接字</span>
tcp_client_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><p><img src="`+f+'" alt="运行结果" loading="lazy"></p><p>如果忘记设置端口的关闭，非正常退出会导致端口一直被占用</p><p>linux 环境在终端执行 <code>ps aux | grep py</code> 查看运行的进程，然后 <code>kill -9 pid</code> 杀掉进程</p><h3 id="建立连接-三次握手" tabindex="-1"><a class="header-anchor" href="#建立连接-三次握手" aria-hidden="true">#</a> 建立连接（三次握手）</h3><p><img src="'+T+'" alt="三次握手" loading="lazy"></p><p>SYN：连接请求 ACK：确认 FIN：关闭连接 seq：报文信号 ack：确认信号</p><ol><li><p>第一次握手：client 标志位 SYN 置 1，随机产生一个 seq=J，并将该数据包发送给 serve，client 进入 SYN_SENT 状态，等待 serve 确认</p></li><li><p>第二次握手：serve 收到数据包后由标志位 SYN=1 知道 client 请求建立连接，serve 将 SYN 和 ACK 都置 1，ack（number）=J+1，+1 是逻辑加一（加密），随机产生一个值 seq=K，并将该数据包发送给 client 以确认连接请求，serve 进入 SYN_RECV 状态</p></li><li><p>第三次握手：client 收到确认，检查 ack 是否为 J+1（解密），如果正确则将标志位 ACK 置 1，ack=K+1，并将该数据包发送给 serve，serve 检查 ack 是否为 K+1，如果正确则建立连接成功，client 和 serve 同时进入 ESTABLISHED 状态，完成三次握手，随后 client 和 serve 之间可以传输数据</p></li></ol><h3 id="断开连接-四次挥手" tabindex="-1"><a class="header-anchor" href="#断开连接-四次挥手" aria-hidden="true">#</a> 断开连接（四次挥手）</h3><p><img src="'+P+'" alt="四次挥手" loading="lazy"></p><ol><li><p>第一次挥手：client 发送一个 FIN，用来关闭 client 到 serve 的数据传送</p></li><li><p>第二次挥手：serve 收到 FIN 后，发送一个 ACK 给 client，确认序号为收到序号 + 1，表示还有剩余数据未传送完</p></li><li><p>第三次挥手：serve 发送一个 FIN，用来关闭 serve 到 client 的数据传送</p></li><li><p>第四次挥手：client 收到 FIN 后，接着发送一个 ACK 给 serve，确认序号为收到信号 + 1</p></li></ol>',20),ls=e("p",null,"Q: TCP 传输中的 Segment 是什么？",-1),os=e("p",null,"A: 是该协议负责传输的数据单元的专用名词。在 TCP 协议中，分段（segment）是指将传输的数据分割成多个较小的部分，以便更有效地在网络上传输。每个分段包含在 TCP 首部中的控制信息，如端口号、序列号和确认号等，以及在数据字段中携带的有效负载部分。分段的大小可以根据不同的网络条件进行调整，以最大程度地减少重传或延迟。在接收方，TCP 会将收到的分段重新组合成完整的数据，以保证传输的准确性和完整性。",-1);function rs(cs,ds){const s=l("ExternalLinkIcon");return o(),r("div",null,[S,e("blockquote",null,[e("p",null,[e("a",w,[n("用大白话解释什么是 Socket - 知乎 (zhihu.com)"),t(s)])]),D,x]),N,e("blockquote",null,[e("p",null,[e("a",C,[n("TCP 和 UDP 的区别 - 知乎 (zhihu.com)"),t(s)])]),A]),I,e("blockquote",null,[e("p",null,[e("a",H,[n("HTTP 的发展 - HTTP | MDN (mozilla.org)"),t(s)])]),M,E,q,e("ul",null,[e("li",null,[n("一个用来表示超文本文档的文本格式，"),e("em",null,[e("a",z,[n("超文本标记语言"),t(s)])]),n("（HTML）。")]),U,L,W]),R,O,e("p",null,[n("最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法 "),e("a",F,[G,t(s)]),n(" 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。")]),B,e("ul",null,[K,V,j,e("li",null,[n("在新 HTTP 标头的帮助下，具备了传输除纯文本 HTML 文件以外其他类型文档的能力（凭借 "),e("a",Y,[Q,t(s)]),n(" 标头）。")])]),J,e("p",null,[n("在 1991-1995 年，这些新扩展并没有被引入到标准中以促进协助工作，而仅仅作为一种尝试。服务器和浏览器添加这些新扩展功能，但出现了大量的互操作问题。直到 1996 年 11 月，为了解决这些问题，一份新文档（RFC 1945）被发表出来，用以描述如何操作实践这些新扩展功能。文档 "),e("a",X,[n("RFC 1945"),t(s)]),n(" 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。")]),Z,$,ee,e("ul",null,[ne,se,te,ae,ie,e("li",null,[n("凭借 "),e("a",le,[oe,t(s)]),n(" 标头，能够使不同域名配置在同一个 IP 地址的服务器上。")])]),re,e("p",null,[n("HTTP/1.1 在 1997 年 1 月以 "),e("a",ce,[n("RFC 2068"),t(s)]),n(" 文件发布。")]),e("p",null,[n("由于 HTTP 协议的可扩展性使得创建新的头部和方法是很容易的。即使 HTTP/1.1 协议进行过两次修订，"),e("a",de,[n("RFC 2616"),t(s)]),n(" 发布于 1999 年 6 月，而另外两个文档 "),e("a",pe,[n("RFC 7230"),t(s)]),n("-"),e("a",ue,[n("RFC 7235"),t(s)]),n(" 发布于 2014 年 6 月（在 HTTP/2 发布之前）。HTTP/1.1 协议已经稳定使用超过 15 年了。")])]),he,e("blockquote",null,[e("p",null,[e("a",me,[n("HTTP 响应状态码 - HTTP | MDN (mozilla.org)"),t(s)])]),e("p",null,[n("HTTP 响应状态码用来表明特定 "),e("a",ve,[n("HTTP"),t(s)]),n(" 请求是否成功完成。 响应被归为以下五大类：")]),e("ol",null,[e("li",null,[e("a",be,[n("信息响应"),t(s)]),n(" ("),ge,n("–"),ke,n(")")]),e("li",null,[e("a",_e,[n("成功响应"),t(s)]),n(" ("),fe,n("–"),Te,n(")")]),e("li",null,[e("a",Pe,[n("重定向消息"),t(s)]),n(" ("),ye,n("–"),Se,n(")")]),e("li",null,[e("a",we,[n("客户端错误响应"),t(s)]),n(" ("),De,n("–"),xe,n(")")]),e("li",null,[e("a",Ne,[n("服务端错误响应"),t(s)]),n(" ("),Ce,n("–"),Ae,n(")")])]),e("p",null,[n("**备注：**如果您收到的响应不在 "),e("a",Ie,[n("此列表"),t(s)]),n(" 中，则它为非标准响应，可能是服务器软件的自定义响应。")]),e("p",null,[e("a",He,[n("HTTP response status codes - PlayFab | Microsoft Learn"),t(s)])]),Me]),Ee,e("blockquote",null,[e("p",null,[e("a",qe,[n("Introduction to Electronic Mail - GeeksforGeeks"),t(s)])]),ze,Ue,Le]),We,Re,Oe,Fe,Ge,e("ol",null,[Be,Ke,e("li",null,[Ve,e("blockquote",null,[e("p",null,[e("a",je,[n("What is the Simple Mail Transfer Protocol (SMTP)? | Cloudflare"),t(s)])]),e("p",null,[n("The server runs a program called a Mail Transfer Agent (MTA). The MTA checks the domain of the recipient's email address, and if it differs from the sender's, it queries the "),e("a",Ye,[n("Domain Name System (DNS)"),t(s)]),n(" to find the recipient's "),e("a",Qe,[n("IP address"),t(s)]),n(". This is like a post office looking up a mail recipient's zip code.")])])]),Je]),Xe,Ze,e("blockquote",null,[e("p",null,[e("a",$e,[n("What is the Simple Mail Transfer Protocol (SMTP)? | Cloudflare"),t(s)])]),en]),nn,e("blockquote",null,[e("p",null,[e("a",sn,[n("什么是 DNS？ - 知乎 (zhihu.com)"),t(s)])]),tn]),an,e("blockquote",null,[e("p",null,[e("a",ln,[n("什么是 DNS-DNS 如何工作-权威性 DNS 服务器 | Cloudflare 中国官网 | Cloudflare"),t(s)])]),on,e("ul",null,[e("li",null,[e("strong",null,[e("a",rn,[n("DNS 解析器"),t(s)])]),n("：该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。DNS 解析器是一种服务器，旨在通过 Web 浏览器等应用程序接收客户端计算机的查询。然后，解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。")]),e("li",null,[e("strong",null,[e("a",cn,[n("根域名服务器"),t(s)])]),n("：根域名服务器是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。")]),e("li",null,[e("strong",null,[e("a",dn,[n("TLD 名称服务器"),t(s)])]),n("：顶级域名服务器（"),e("a",pn,[n("TLD"),t(s)]),n("，Top-level domain）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。")]),e("li",null,[e("strong",null,[e("a",un,[n("权威性域名服务器"),t(s)])]),n("：可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。")])]),hn,e("p",null,[n("这两个概念都是指 DNS 基础设施不可或缺的服务器（服务器组），但各自担当不同的角色，并且位于 DNS 查询管道内的不同位置。考虑二者差异的一种方式是，"),e("a",mn,[n("递归"),t(s)]),n("解析器位于 DNS 查询的开头，而权威性域名服务器位于末尾。")]),vn,e("p",null,[n("递归解析器是一种计算机，其响应来自客户端的递归请求并花时间追踪 "),e("a",bn,[n("DNS 记录"),t(s)]),n("。为执行此操作，其发出一系列请求，直至到达用于所请求的记录的权威性 DNS 域名服务器为止（或者超时，或者如果未找到记录，则返回错误）。幸运的是，递归 DNS 解析器并不总是需要发出多个请求才能追踪响应客户端所需的记录；"),e("a",gn,[n("缓存"),t(s)]),n("是一种数据持久性过程，可通过在 DNS 查找中更早地服务于所请求的资源记录来为所需的请求提供捷径。")]),kn,e("ol",null,[_n,e("li",null,[e("p",null,[n("浏览器向该 IP 地址发出"),e("a",fn,[n("HTTP"),t(s)]),n(" 请求。")])]),Tn]),Pn,yn,e("p",null,[n("缓存的目的是将数据临时存储在某个位置，从而提高数据请求的性能和可靠性。DNS 高速缓存涉及将数据存储在更靠近请求客户端的位置，以便能够更早地解析 DNS 查询，并且能够避免在 DNS 查找链中进一步向下的额外查询，从而缩短加载时间并减少带宽/CPU 消耗。DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录并保存由"),e("a",Sn,[n("生存时间（TTL，time to live）"),t(s)]),n("决定的一段时间。")]),wn,Dn,xn,Nn,Cn,An,In,e("ol",null,[e("li",null,[n("如果解析器没有 "),e("a",Hn,[n("A 记录"),t(s)]),n("，但确实有针对权威性域名服务器的 "),e("a",Mn,[n("NS 记录"),t(s)]),n("，则其将直接查询这些域名服务器，从而绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 域名服务器（在我们对 example.com 的搜索中）进行查找，并且有助于更快地解析 DNS 查询。")]),En,qn])]),zn,e("blockquote",null,[e("p",null,[e("a",Un,[n("DNS 记录 | Cloudflare"),t(s)])]),e("p",null,[e("a",Ln,[n("DNS"),t(s)]),n(" 记录（又名区域文件）是位于权威 "),e("a",Wn,[n("DNS 服务器"),t(s)]),n("中的指令，提供一个域的相关信息，包括哪些 "),e("a",Rn,[n("IP 地址"),t(s)]),n("与该域关联，以及如何处理对该域的请求。这些记录由一系列以所谓的 DNS 语法编写的文本文件组成。DNS 语法是用作命令的字符串，这些命令告诉 DNS 服务器执行什么操作。此外，所有 DNS 记录都有一个 “"),e("a",On,[n("TTL"),t(s)]),n("”，其代表生存时间，指示 DNS 服务器多久刷新一次该记录。")]),Fn]),Gn,e("blockquote",null,[e("p",null,[e("a",Bn,[n("Building TCP and UDP Client-Server Interactions | by Matthew MacFarquhar | Dev Genius"),t(s)])]),Kn,Vn]),jn,e("blockquote",null,[e("p",null,[e("a",Yn,[n("Python 绝技 —— UDP 服务器与客户端 - i 春秋 - 博客园 (cnblogs.com)"),t(s)])]),Qn]),Jn,Xn,e("blockquote",null,[e("p",null,[e("a",Zn,[n("UDP - Client and Server example programs in Python | Pythontic.com"),t(s)])]),$n]),es,e("blockquote",null,[e("p",null,[e("a",ns,[n("【Python】UDP/TCP_种花家 de 小红帽的博客-CSDN 博客"),t(s)])]),ss]),ts,e("blockquote",null,[e("p",null,[e("a",as,[n("【Python】UDP/TCP_种花家 de 小红帽的博客-CSDN 博客"),t(s)])]),is]),ls,os])}const us=i(y,[["render",rs],["__file","02-application-layer.html.vue"]]);export{us as default};

import{_ as l,r,o as d,c,a as e,b as t,d as a,w as o,e as s}from"./app-3bc34864.js";const p="data:image/png;base64,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",h="/assets/6d5c25bbe2e5400fbc9335d7050819c1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-bc291cbe.webp",m="/assets/image-20230330182543746-18712684.png",u="/assets/image-20230406160254181-f81eb35b.png",g="/assets/image-20230406160405036-eb4b4836.png",f="/assets/a09a430b0b4b42d8adaebd53c2d18ca7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-96145c6c.webp",b="/assets/2f304e43b0aa44fba18c7957739b64c3tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-a1fdc17c.webp",_="/assets/388b53a2a1754fa3917c73567a08635etplv-k3u1fbpfcp-zoom-in-crop-mark4536000-4d01f083.webp",k="/assets/41aa6511fa604ded83b8a5cc70638a5dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000-a80fd8e1.webp",w="/assets/8cc24713a4d94435a4c38bcb73f2fb1ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000-bd0bdca1.webp",y="/assets/cd9a09430db5426da3258968f0138b4ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000-580e2873.webp",A="/assets/image-20230406170657367-fc64aa3a.png",v="/assets/image-20230406170731751-1680772053149-27-369c27d5.png",C="/assets/image-20230406170943445-dcb135e9.png",x="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1df09bec.png",T="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771028064-15-ab904db4.png",P="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771156231-18-20422705.png",K="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771627922-21-140cf4be.png",z="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771724108-24-fe2c1379.png",D="/assets/GoBackN-4-2fa67c1c.webp",S="/assets/image-20230406181022884-2afb537f.png",N="/assets/e5fdf560fdb40a1c0b3c3ce96f570e5f00fff161-72925572.png",E="/assets/image-6e9e29f8.png",q="/assets/image-20230413161231370-2587cc4c.png",F="/assets/image-20230413162814647-1c4bc0f2.png",R="/assets/image-20230413163235946-1704d6a2.png",B="/assets/v2-a1c07b4e4f4b42983af6750f3624e51d_b-56dd1dee.jpg",I="/assets/v2-4b53936be09ea0ad5b9c02d4ab2715f1_b-22b14d54.jpg",O="/assets/image-20230413173431851-470365a2.png",U="/assets/image-20230413173420182-649af970.png",Y="/assets/v2-6d090720878e33df5726c381d33ce6f4_b-e9d047f8.jpg",H="/assets/v2-3319d090787d8941cea25376e284679b_b-5ea866d3.jpg",Q={},j=s('<h2 id="outline" tabindex="-1"><a class="header-anchor" href="#outline" aria-hidden="true">#</a> Outline</h2><ol><li><p>Transport-layer services</p></li><li><p>Multiplexing and demultiplexing</p></li><li><p>Connectionless transport: UDP</p></li><li><p>Principles of reliable data transfer</p></li><li><p>Connection-oriented transport: TCP</p><ul><li>segment structure</li><li>reliable data transfer</li><li>flow control</li><li>connection management</li></ul></li><li><p>Principles of congestion control</p></li><li><p>TCP congestion control</p></li></ol><h2 id="transport-layer-services" tabindex="-1"><a class="header-anchor" href="#transport-layer-services" aria-hidden="true">#</a> Transport-layer services</h2><h3 id="transport-vs-network-layer" tabindex="-1"><a class="header-anchor" href="#transport-vs-network-layer" aria-hidden="true">#</a> Transport vs. network layer</h3><p>网络层是协议栈中的第三层，负责处理互联网上每个主机之间的路由。该层有两个主要的任务：</p><ol><li>选择最佳路径将数据包发送到目标地址；</li><li>控制每个数据包在网络中的传输。网络层协议常用的是 IP（Internet Protocol），它定义了如何通过互联网把数据包从源主机传输到目标主机。</li></ol><p>传输层是协议栈中的第四层，是端到端通信的主要协议。传输层实现了数据传输的可靠性，并采用流控制和拥塞控制等机制来协调系统中的数据流。该层的两个最常用的协议是 TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）。TCP 提供可靠的数据传输，而 UDP 则提供无连接、不可靠和基于报文的传输。</p><p>因此，网络层和传输层具有不同的目的和职责。网络层处理路由和数据包转发，而传输层负责端到端通信可靠性，数据流控制和拥塞控制等方面的任务。</p><h2 id="multiplexing-and-demultiplexing" tabindex="-1"><a class="header-anchor" href="#multiplexing-and-demultiplexing" aria-hidden="true">#</a> Multiplexing and demultiplexing</h2>',9),M={href:"https://blog.csdn.net/SongXJ_01/article/details/106880461",target:"_blank",rel:"noopener noreferrer"},G=s('<h3 id="multiplexing-多路复用" tabindex="-1"><a class="header-anchor" href="#multiplexing-多路复用" aria-hidden="true">#</a> Multiplexing 多路复用</h3><p>从源主机的不同套接字（socket）中收集数据块，并为每个数据块封装上首部信息（这将在多路分解时使用）从而生成报文段（segment），然后将报文段传递到网络层的工作称为多路复用。</p><ul><li>在 TCP 或者 UDP 传输过程中，数据需要被不同程序识别，multiplexing 因此诞生</li><li>一般情况下 multiplexing 有以下几个 field 用于区分不同程序所需要的数据 source ip, source port, destination ip, destination port</li></ul><h3 id="demultiplexing-多路分解" tabindex="-1"><a class="header-anchor" href="#demultiplexing-多路分解" aria-hidden="true">#</a> Demultiplexing 多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><ul><li>通过检验上述 field, 传输协议（transport layer protocol）将不同数据包发送至正确的 socket port</li><li>0-1023 是被各种协议占用的端口，1024-65535 是一般程序可用的端口</li></ul>',6),L=s('<h2 id="connectionless-transport-udp" tabindex="-1"><a class="header-anchor" href="#connectionless-transport-udp" aria-hidden="true">#</a> Connectionless transport: UDP</h2><h3 id="udp-user-datagram-protocol-rfc-768" tabindex="-1"><a class="header-anchor" href="#udp-user-datagram-protocol-rfc-768" aria-hidden="true">#</a> UDP: User Datagram Protocol [RFC 768]</h3><p>基础原理已经在 <a href="./02-application-layer#client-server-socket-udp">Chapter 2 @ Client/server socket: UDP</a> 讲过，不再赘述。</p><h3 id="udp-segment-header" tabindex="-1"><a class="header-anchor" href="#udp-segment-header" aria-hidden="true">#</a> UDP: segment header</h3>',4),V={href:"https://www.computernetworkingnotes.com/ccna-study-guide/segmentation-explained-with-tcp-and-udp-header.html",target:"_blank",rel:"noopener noreferrer"},X=s('<h3 id="segmentation" tabindex="-1"><a class="header-anchor" href="#segmentation" aria-hidden="true">#</a> Segmentation</h3><p>Segmentation is the process of dividing large data stream into smaller pieces. This functionality allows a host to send or receive a file of any size over the any size of network. For example, if network bandwidth is 1 Mbps and file size is 100 Mb, host can divide the file in 100 or more pieces. Once a piece becomes less or equal to the network bandwidth in size, it can be transferred easily. Destination host, upon(在…之后) receiving all pieces, joins them back to reproduce the original file.</p><p>If an application wants to use UDP to send its data, it can’t give the data to UDP in actual size. It has to use its own mechanism(机制) to detect whether segmentation is required or not. And if segmentation is required, it has to do it on its own before giving data to UDP.</p><h3 id="packing-data-for-transmission" tabindex="-1"><a class="header-anchor" href="#packing-data-for-transmission" aria-hidden="true">#</a> Packing data for transmission</h3><p>Both protocols pack data in similar fashion. Both add a header with each data piece. A header mainly contains two types of information;</p><ol><li>The information that is required to send the segment at the correct destination.</li><li>The information that is required to support the protocol specific features.</li></ol><h3 id="how-udp-work-with-header" tabindex="-1"><a class="header-anchor" href="#how-udp-work-with-header" aria-hidden="true">#</a> How UDP Work with header</h3><p>UDP neither provides any protocol specific service, nor adds any additional information in the header.</p><p>Following figure shows data with UDP header.</p><p><img src="'+p+'" alt="UDP header" loading="lazy"></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Source port</td><td>Port number of the application that is transmitting data from the source computer</td></tr><tr><td>Destination port</td><td>Port number of the application that will receive the data at destination.</td></tr><tr><td>Length</td><td>Denotes the length of the UDP header and the UDP data</td></tr><tr><td>Checksum</td><td>CRC of the complete segment</td></tr><tr><td>Data</td><td>Data which it received from the application</td></tr></tbody></table>',11),Z=s('<h3 id="udp-checksum" tabindex="-1"><a class="header-anchor" href="#udp-checksum" aria-hidden="true">#</a> UDP checksum</h3><p>Goal: detect “errors” (e.g., flipped bits(比特位的翻转)) in transmitted segment</p><p>UDP（用户数据报协议）checksum 是一种用于检测 UDP 数据包完整性的简单校验和。当 UDP 数据包被发送到网络时，发送端计算校验和并将其添加到 UDP 数据包中的 checksum 字段中。接收端通过再次计算校验和并将其与数据包的 checksum 字段进行比较来检测数据包是否在传输过程中出现任何错误或损坏。如果计算出的校验和不匹配，则数据包被认为是损坏的。UDP 校验和是 UDP 协议的一项重要功能，可确保数据在传输过程中的完整性和正确性。</p><h2 id="principles-of-reliable-data-transfer" tabindex="-1"><a class="header-anchor" href="#principles-of-reliable-data-transfer" aria-hidden="true">#</a> Principles of reliable data transfer</h2><p>Characteristics(特点) of unreliable channel will determine(决定) complexity of reliable data transfer protocol.</p><div class="custom-container tip"><p>Reliable data transfer(rdt) 即可靠传输。</p></div>',6),W={href:"https://juejin.cn/post/7030066301062086670",target:"_blank",rel:"noopener noreferrer"},J=s('<p><img src="'+h+'" alt="image.png" loading="lazy"></p><h3 id="rdt-1-0" tabindex="-1"><a class="header-anchor" href="#rdt-1-0" aria-hidden="true">#</a> rdt 1.0</h3><p>rdt 1.0 是基于<strong>理想情况下</strong>的协议，假设所有信道都是可靠的——没有比特位的翻转，没有数据包的丢失与超时。所以 rdt 1.0 的传输功能就是：<strong>发送方发送数据，接收方等着接受数据</strong>。</p><p><img src="'+m+'" alt="image-20230330182543746" loading="lazy"></p><h3 id="rdt-2-0" tabindex="-1"><a class="header-anchor" href="#rdt-2-0" aria-hidden="true">#</a> rdt 2.0</h3><ul><li>rdt 2.0 在 rdt1.0 的基础上考虑了 <strong>bit errors</strong>，即，不可信信道中数据包中的 1 可能会变 0，0 可能会变成 1。rdt2.0 的任务是<strong>发现并修复</strong>这些 bit errors</li><li>rdt 1.0 中接受者和发送者固定，rdt2.0 引入有限状态自动机 finite state machines (FSM) 来切换指定发送者和接受者</li></ul><div class="custom-container tip"><p class="custom-container-title">Finite State Machines</p><p>即只有有限种状态的，在特定条件下能切换状态的机器。比如刷卡就转的这种门禁机器。</p></div><p>rdt 2.0 增加了 3 种新机制来提升：</p><ol><li><p>通过 checksum 来错误校验</p></li><li><p>接收者反馈接受正误信息（Acknowledgements）：</p><ul><li>acknowledgements (ACKs): receiver explicitly(明确地) tells sender that pkt() received OK</li><li>negative acknowledgements (NAKs): receiver explicitly tells sender that pkt had errors</li></ul><div class="custom-container tip"><p class="custom-container-title">这也叫做停等协议（Stop and wait）</p><p>sender sends one packet, then waits for receiver response</p></div></li><li><p>出错就重传</p></li></ol><p>即，传输层对应用层的数据进行打包处理时，新增 checksum（校验和），从而接收端可以对其数据包进行检验，如果正确，返回 ACK，发送者继续发送下一个数据包；如果不正确，返回 NAK，发送者重传数据。</p><p><img src="'+u+'" alt="image-20230406160254181" loading="lazy"></p><p>但如果客户端在接受后反馈信息 ACKs 在传输过程中出现问题，导致回答的内容在服务端看来并非 ACKs，服务端/发送端会重新回传内容。</p><p><img src="'+g+'" alt="image-20230406160405036" loading="lazy"></p><p>这也是 rdt 2.0 的一些大问题。不能只是简单地重发，可能重复了就麻烦了。因此 rdt 2.1 应运而生。</p><h3 id="rdt-2-1" tabindex="-1"><a class="header-anchor" href="#rdt-2-1" aria-hidden="true">#</a> rdt 2.1</h3><p>如何解决重复呢：</p><ul><li>如果 ACK 或者 NAK 错了，corrupted(损坏) 了，还是重发</li><li>但是这回，发送方在打包数据包时添加了 0 或者 1 编号 sequence number (seq)（两个状态就够啦，一次只发送一个未经确认的分组）</li><li>sender 就有 0 号数据包和 1 号 package 两种；receiver 也有了 2 种状态等待 0 号 package 和等待 1 号 package</li><li>receiver 把序列重复的删了不接受即可（receiver 也不知道发送方是否正确收到了其 ACK/NAK）</li><li>需要“stop and wait”，发送方发送一个 package，然后等待接收方响应</li></ul><p>对于 Sender：</p><p><img src="'+f+'" alt="image.png" loading="lazy"></p><p>对于 Receiver：</p><p><img src="'+b+'" alt="image.png" loading="lazy"></p><p>整体（基本上记这个就差不多）：</p><p><img src="'+_+'" alt="image.png" loading="lazy"></p><h3 id="rdt-2-2" tabindex="-1"><a class="header-anchor" href="#rdt-2-2" aria-hidden="true">#</a> rdt 2.2</h3><p>做了一点点微不足道的改进，再见啦 NAK，ACK 就够了</p><p><strong>我们在 ACK 的信息上加上了顺序号（sequence number）</strong>：sender 发送 0 号数据包，如果接收方正确接收到 0 号，返回（ACK0），发送方接着发送 1 号数据包。如果接收方没有接收到 0 号数据包或出现错误，返回（ACK1），发送方重传 0 号数据包。</p><div class="custom-container tip"><p>相当于抽象成了“若不符合要求，重发”和“发新的”两个选项</p></div><p><img src="'+k+'" alt="image.png" loading="lazy"></p><p><img src="'+w+'" alt="image.png" loading="lazy"></p><p><img src="'+y+'" alt="image.png" loading="lazy"></p><h3 id="rdt-3-0" tabindex="-1"><a class="header-anchor" href="#rdt-3-0" aria-hidden="true">#</a> rdt 3.0</h3><p>rdt2.2 之前的版本都重在处理数据包的 bit errors 情况，却没有考虑到数据包在传输过程中出现的<strong>数据包或者 ACKs 丢失</strong>问题，这样数据包丢失会使得网络处于拥塞状态</p><p>机制（解决方法）：在超过合理时间（reasonable amount of time，同 TCP）后重传</p><ul><li>发送端超时重传：如果到时没有收到 ACK-&gt;重传</li><li>如果 package（或 ACK）只是被延迟了： <ul><li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li><li>接收方必须指明被正确接收的序列号</li></ul></li><li>需要一个倒计数定时器</li></ul><p><img src="'+A+'" alt="image-20230406170657367" loading="lazy"></p><p><img src="'+v+'" alt="image-20230406170731751" loading="lazy"></p><p><img src="'+C+'" alt="image-20230406170943445" loading="lazy"></p><p>过早超时(延迟的 ACK)也能够正常工作：但是效率较低，一半包和确认是重复的。</p>',38),$={href:"https://blog.csdn.net/m0_63657524/article/details/121916128",target:"_blank",rel:"noopener noreferrer"},ee=s('<p>计算机网络通过对网络进行分层设计，将一个庞大而复杂的系统，模块化层次化，（ 大致分层如图 2.1 所示 ） 其中的每个层次为其上层提供特定的服务内容，并使用来自下层的特定功能，各个层次中明确了其需要实现的内容，但并不指明其中具体的实现方式。</p><p>运行在应用层中的客户端（服务端）应用程序进程通过套接字将数据推送到运输层。同样地，有服务端（客户端）进程通过套接字接受来自运输层的数据。对应用层而言，它所能看到的底层就是一条可靠的信道（如图 2.2 所示）。但是，对于现实中的数据传输，由于受到噪声干扰、网络拥堵等各种影响，难免会出现数据受损、丢包等事故，而 rdt 协议就是为了解决这样一个问题，而诞生的。</p><p><img src="'+x+'" alt="img" loading="lazy"></p><h3 id="rdt-协议的实现" tabindex="-1"><a class="header-anchor" href="#rdt-协议的实现" aria-hidden="true">#</a> rdt 协议的实现</h3><p>参考《计算机网络自顶向下》这本书，在这里我们从简单到复杂来探讨这个协议的实现过程（要注意的是，我们在此处探讨的 rdt 协议是建立在（stop-and-wait）停等协议上的。</p><p>首先，先将各个部分做好定义和命名初始化处理, 为进一步探讨协议做好准备。</p><p>我们将数据的发送方设定为 sender，接收方设定为 receptor，发送方和接收方各自维护一个自己 FSM(Finite-State-Machine)有限状态机，用于记录当前的状态。我们用状态来描述发送方和接收方在执行通讯各个时期的特征。</p><h3 id="rdt-协议-1-0" tabindex="-1"><a class="header-anchor" href="#rdt-协议-1-0" aria-hidden="true">#</a> rdt 协议 1.0</h3><p>在 rdt 1.0 中我们只专注于考虑如何实现核心功能，而不去考虑其他异常。因此我们在此处假定两个应用层之间存在着这么一条可靠信道，它可以保证从应用层的一侧到另一侧数据不丢失，因此此时的发送方和接收方只会有一个状态。</p><ul><li>发送方： 等待应用程序下发调用指令，发送数据</li><li>接收方： 等待来自下层的调用指令，接受数据并缓存</li></ul><p><img src="'+T+'" alt="img" loading="lazy"></p><p>数据流动情况分析</p><p>sender：</p><ul><li>应用进程调用 rdt_send（data）方法，将数据推送至运输层</li><li>运输层调用 make_pkt 方法，将源自于应用程序的报文分组打包成报文段</li><li>运输层调用 udt_send 方法，将报文段推送至信道</li></ul><p>receptor：</p><ul><li>较低层（比运输层低的层次）执行 ret_rev 方法，将数据推送到运输层</li><li>运输层调用 extract，从报文段中提取出数据（可能涉及分组等细节实现，此处不作探讨）</li><li>运输层调用 deliver_data 方法将数据推送至应用层</li></ul><p>此时，我们就可以简单地实现让数据从 sender 端传输到 receptor 端了，当然此时距离可靠数据传输还有一定的距离。因此，在 rdt2.0 及以后的版本我们开始考虑当异常事件发生的时候，如何保证数据的可靠性</p><h3 id="rdt-协议-2-0" tabindex="-1"><a class="header-anchor" href="#rdt-协议-2-0" aria-hidden="true">#</a> rdt 协议 2.0</h3><p>在 rdt 2.0 首先考虑比特差错出现的情况，比特差错通常会出现在可能受损的物理部件之中，因此需要引入比特差错矫正的功能。（udp 的比特差错校验方法）在考虑出现比特差错事件发生的 rdt 2.0 中，需要加入 肯定确认（ACK positive acknowledgement）、否定确认（NAK negative acknowledgement）的情况。对于否定确认的报文，需要提示发送方重新发送该数据（数据恢复）。基于这种重传机制的可靠数据传输协议称为 自动重传协议（Automatic Repeat reQuest，ARQ）</p><p>于是 Sender 方需要增加一个状态，等待 ACK 或 NAK，整个 rdt 2.0 执行流程如图所示：</p><p><img src="'+P+'" alt="img" loading="lazy"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li>应用层调用 rdt_send 方法，将数据推送至应用层</li><li>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码</li><li>应用层调用 udt_send 方法将打包完成的报文段推送至信道</li><li>Sender 端 此时状态迁移为 等待 ACK 应答 或者 NAK 应答状态</li></ul><p>Receptor 端：</p><ul><li>较低层通过 rdt_rcv 方法，将数据推送到运输层</li><li>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则跳转到第 3 步</li><li>发送 NAK 指令，继续等待较低层的调用</li><li>发送 ACK 指令，继续等待较低层的调用</li></ul><p>Sender 端：</p><ul><li>接收到 NAK 应答指令执行第 2 步，接收到 ACK 执行第 3 步</li><li>接收到 NAK，Sender 直接将打包好的数据再一次通过 udt_send 方法推送到信道, 保持等待 ACK 或 NAK 指令状态</li><li>接受到 ACK，Sender 端不再阻塞，可以发送新的数据，状态迁移为等待上层调用状态</li></ul><p>需要注意的是：由于在这里讨论的 rdt 协议采用了停等协议。因此，Sender 端在等待 ACK 和 NAK 答复指令的时候，处在阻塞的状态。</p><h3 id="rdt-协议-2-1" tabindex="-1"><a class="header-anchor" href="#rdt-协议-2-1" aria-hidden="true">#</a> rdt 协议 2.1</h3><p>（rdt 2.1 为什么不效仿 rdt 2.0 中，让 receptor 端去接受一个 ack 或 nak，这是因为可能出现一个比较有趣的问题，这个问题后续讨论）</p><p>数据流动如图所示：</p><p><img src="'+K+'" alt="img" loading="lazy"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li>应用层调用 rdt_send 方法，将数据推送至应用层</li><li>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码和一个值为 0 或 1 的序号</li><li>应用层调用 udt_send 方法将打包完成的报文段推送至信道</li><li>Sender 端 此时状态迁移为 等待序号为 0 或 1 的报文段 ACK 应答 或 NAK 应答状态</li></ul><p>Receptor 端：</p><ul><li>较低层通过 rdt_rcv 方法，将数据推送到运输层</li><li>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</li><li>发送 NAK 指令，继续等待下层调用</li><li>检测数据序号，如果是冗余数据，直接丢弃数据，发送对缓存栈中数据的 ACK 指令，对于非冗余数据，则将数据置换到缓存栈之中，发送一个确认对本次数据的 ACK 指令，继续等待来自下层的调用</li></ul><p>Sender 端：</p><ul><li>接收到应答指令后，进行数据校验处理，如果数据校验错误，直接重传上次数据，如果数据校验正确，则执行第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 执行第 3 步，如果指令为 NAK 执行第 4 步</li><li>接收到 ACK 指令，Sender 端不再阻塞，可以发送新的数据 1 或 0，状态迁移到 等待来自上层调用</li><li>接收到 NAK 指令，重传上次数据，状态迁移到：等待 ACK 或 NAK 状态</li></ul><h3 id="rdt-协议-2-2" tabindex="-1"><a class="header-anchor" href="#rdt-协议-2-2" aria-hidden="true">#</a> rdt 协议 2.2</h3><p>实际上 rdt 2.2 并没有做出更多变更，它只是在 rdt2.1 基础上进行了一次逻辑优化，因为有了序号的存在，receptor 端不在需要用 NAK 指令去表示收到的数据产生了比特错误。 取而代之是，对于比特受损的数据，receptor 端直接丢弃，并发送一个对缓存区数据的确认 ACK（一开始缓存区为空也不要紧，由于序列是 010101 交替的序列，只要发送一个与当前 ACK 不同的序号即可），而此时，Sender 端也需要维护一个缓存，用于记录上一次发送的数据，当接受到的 ACK 与缓存序列号相同，那么就表示发送的数据发生了比特差错，此时重新发送一次缓存区中的数据即可。</p><p><img src="'+z+'" alt="img" loading="lazy"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li>应用层调用 rdt_send 方法，将数据推送至应用层</li><li>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码，和一个值为 0 或 1 的序号 ，并将其存储至缓存区</li><li>应用层调用 udt_send 方法将打包完成的报文段推送至信道</li><li>Sender 端 此时状态迁移为 等待序号为 0 或 1 的报文段 的 ACK 或 NAK 应答状态</li></ul><p>Repetor 端：</p><ul><li>较低层通过 rdt_rcv 方法，将数据推送到运输层</li><li>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</li><li>发送缓存区数据序号的确认 ACK 指令，保持等待下层调用的状态</li><li>检测本次数据序号，如果是冗余数据，直接丢弃数据，发送缓存栈中数据序号的 ACK 指令，对于非冗余数据，将数据置换到缓存区之中，并发送一个对本次数据序号的确认 ACK 指令</li></ul><p>Sender 端：</p><ul><li>接收到应答指令后进行数据校验处理，如果数据校验错误，直接重新发送上次数据，如果正确则执行第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 中的序号等于缓存区的序号，执行第 3 步，如果 ACK 指令序号不等于缓存区序号则执行 第 4 步</li><li>重新发送上次数据，状态迁移到 等待 ACK 应答指令</li><li>Sender 端不再阻塞，可以发送新的序号为 1 或者 0 的数据，状态迁移到 等待来自上层调用</li></ul><h3 id="rdt-协议-3-0" tabindex="-1"><a class="header-anchor" href="#rdt-协议-3-0" aria-hidden="true">#</a> rdt 协议 3.0</h3><p>在处理好了比特差错的问题之后，需要考虑的就是来自底层信道传输的另一个问题，丢包异常（ 即发送方或者接受方由于网络阻塞等状况，并没有收到来自于对方的应答数据，在现实中丢包现象是非常常见的），因此，我们可以加入一个定时器来处理丢包现象，当发送一个报文段的时候，就开启一个定时器，在定时器结束期间，如果没有收到对应数据的应答报文，则重传数据。</p><p>数据流动分析</p><p>Sender 端：</p><ul><li>应用层调用 rdt_send 方法，将数据推送至应用层</li><li>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码，和一个值为 0 或 1 的序号 ，并将其存储至缓存区</li><li>应用层调用 udt_send 方法将打包完成的报文段推送至信道，并启动一个定时器事件</li><li>Sender 端 此时状态迁移为 等待序号为 0 或 1 报文段 的 ACK 应答状态</li><li>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 步</li></ul><p>Receptor 端：</p><ul><li>较低层通过 rdt_rcv 方法，将数据推送到运输层</li><li>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</li><li>发送缓存区数据序号的确认 ACK 指令, 同时开启一个定时器，保持等待下层调用的状态</li><li>检测数据序号，如果是冗余数据，直接丢弃数据，发送缓存区中数据序号的 ACK 指令，对于非冗余数据，将数据置换到缓存区中，发送一个对该数据序号的确认 ACK 指令，同时开启一个定时器</li><li>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 或第 4 步</li></ul><p>Sender 端</p><ul><li>接收到应答指令后进行数据校验处理，如果数据校验错误，直接重新发送上次数据，如果正确则执行步第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 中的序号等于缓存区的序号，执行第 3 步，如果 ACK 指令序号不等于缓存区序号则执行 4</li><li>重新发送上次数据，状态迁移到 等待 ACK，同时开启一个定时器</li><li>Sender 端不再阻塞，可以发送新的序号值为 1 或 0 的数据，状态迁移到 等待来自上层调用</li><li>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 或第 4 步</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>至此，在 rdt 3.0 我们已经得到了一个可靠的数据传输协议，当然它只是一个抽象的雏形，建立于停等协议之上，还需要不少细致的优化，让其更好的切合现实，比如如何脱离停等协议实现更高的传输率，以及拥塞控制等等。文章内的方法为了保证准确性，表达式大多参照于《计算机网络自顶向下方法》书籍中的内容，但是为了简化一下表达，也做出了一点变更。</p>',61),te=s('<h3 id="pipelined-protocols" tabindex="-1"><a class="header-anchor" href="#pipelined-protocols" aria-hidden="true">#</a> Pipelined protocols</h3><p>Pipelined protocols(管道协议/窗口协议): sender allows multiple, “in-flight”, yet-to-be-acknowledged pkts</p><ul><li>range of sequence numbers must be increased</li><li>buffering at sender and/or receiver</li></ul><p>Two generic forms of pipelined protocols: go-Back-N(返回 N 个), selective repeat(选择重传)</p><h4 id="go-back-n-返回-n-个" tabindex="-1"><a class="header-anchor" href="#go-back-n-返回-n-个" aria-hidden="true">#</a> Go-back-N(返回 N 个)</h4><ul><li>sender can have up to N unACKed packets in pipeline</li><li>receiver only sends cumulative(累计的) ack: doesn’t ack packet if there’s a gap(有缺口的)</li><li>sender has timer for oldest unACKed packet: when timer expires, retransmit all unACKed packets</li></ul>',6),ae={href:"https://www.baeldung.com/cs/networking-go-back-n-protocol",target:"_blank",rel:"noopener noreferrer"},ne=s('<p>Go-Back-N and Selective(选择性的) Repeat protocols are fundamental(基本的) sliding window protocols(窗口协议) that help us better understand the key idea behind reliable data transfer in the transport layer of computer networks.</p><p>The sliding window (pipelined) protocols achieve utilization(利用) of network bandwidth by not requiring the sender to wait for an acknowledgment before sending another frame.</p><p><strong>In Go-Back-N, the sender controls the flow of packets,</strong> <strong>meaning</strong> <strong>we’ve got a simple and dummy receiver.</strong> Therefore, we’ll start by discussing how the server handles(处理) data packets first.</p><h3 id="sender" tabindex="-1"><a class="header-anchor" href="#sender" aria-hidden="true">#</a> Sender</h3><p>The sender has a sequence of frames to send. We assume a window size of N. Furthermore, there exist two pointers to keep track of send base (send_base) and the next packet to send (nextseqnum).</p><p><img src="'+D+'" alt="GoBackN-4" loading="lazy"></p><p>First of all, the sender starts by sending the first frame. Initially, send_base = 0 and nextseqnum = 0. While there are more packets to send and the nextseqnum is smaller than the send_base + N; the sender sends the packet pointed by the nextseqnum pointer and then increments(递增) the nextseqnum.</p><p>Meanwhile, the send_base is incremented after receiving acknowledgment packets from the receiver. The reception of duplicate ACK messages does not trigger any mechanism.</p><p>There is a single timer for the whole sending window, which measures the timeout for the packet at the send_base. Therefore, if a timeout occurs, the sender restarts the timer and re-transmits all the packets in the sending window starting from send_base.</p><h3 id="receiver" tabindex="-1"><a class="header-anchor" href="#receiver" aria-hidden="true">#</a> Receiver</h3><p>The receiver implementation(实施) of the Go-Back-N is as simple as possible:</p><p>The receiver only keeps track of the expected sequence number to receive next: nextseqnum.</p><p>There is no receiver buffer(缓冲区); out of order packets are simply discarded(丢弃掉). Similarly, corrupted packets are also silently discarded.</p><p>It always sends the acknowledgment for the last in-order packet received upon reception of a new packet (successfully or unsuccessfully). As a result, it will generate duplicate acknowledgment messages if something goes wrong.</p><p>The Go-Back-N protocol adopts the use of cumulative acknowledgments. That is, receiving acknowledgment for frame n means the frames n-1, n-2, and so on are acknowledged as well. We denote such acknowledgments as ACK n.</p>',15),se=e("h4",{id:"selective-repeat-选择重传",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#selective-repeat-选择重传","aria-hidden":"true"},"#"),t(" Selective Repeat(选择重传)")],-1),ie=e("ul",null,[e("li",null,"sender can have up to N unACKed packets in pipeline"),e("li",null,[t("receiver sends "),e("strong",null,"individual ack"),t(" for each packet")]),e("li",null,"sender maintains timer for each unACKed packet: when timer expires, retransmit only that unACKed packet")],-1),re={href:"https://www.baeldung.com/cs/selective-repeat-protocol",target:"_blank",rel:"noopener noreferrer"},oe={href:"https://en.wikipedia.org/wiki/Error_detection_and_correction",target:"_blank",rel:"noopener noreferrer"},le={href:"https://www.baeldung.com/cs/udp-vs-tcp",target:"_blank",rel:"noopener noreferrer"},de={href:"https://www.baeldung.com/cs/tcp-protocol-syn-ack",target:"_blank",rel:"noopener noreferrer"},ce={href:"https://www.baeldung.com/cs/tcp-flow-control-vs-congestion-control",target:"_blank",rel:"noopener noreferrer"},pe=e("strong",null,"the sender and receiver maintain(维持) a window of packets.",-1),he=s('<p>The receiver, in turn, maintains a window of packets that contains the frame number(帧编码) it’s receiving from the sender. If a frame is lost during transmission, the receiver sends the sender a negative acknowledgment attacking the frame number.</p><h3 id="steps" tabindex="-1"><a class="header-anchor" href="#steps" aria-hidden="true">#</a> Steps</h3><p>Now let’s discuss the steps involved in the SRP.</p><p><strong>The first step is to divide data into packets.</strong> The sender divides the data into packets of a fixed size. When the sender divides the data into packets, it assigns <strong>a unique sequence number</strong> to each packet. The numbering of packets plays a crucial role in the SRP.</p><p>The next step is to send the packets to the receiver. The receiver receives the packets and sends an acknowledgment(ACK) for each packet received successfully.</p><p>The sender and receiver maintain a window of packets indicating(指示) the number of frames we can transmit or receive at a given time. Additionally, we determine the size of the window based on the network conditions. As the sender sends packets, it updates its window to reflect(反映) the packets that have been transmitted, and the ACKs received.</p><p>However, if the sender doesn’t receive an ACK for a particular(特指的) packet within a certain timeout period, it retransmits(重传) only that packet instead of the entire set of packets. The receiver only accepts packets that are within its window. If the receiver receives a packet outside the window, it discards(丢弃) the packet.</p><p><strong>The receiver sends selective acknowledgments (SACKs) for packets received out of order or lost.</strong> The sender processes the SACKs to determine which packets need to be retransmitted.</p><p>Finally, we continue this process until we successfully send the data packets or the number of retransmissions exceeds(超过) a predetermined threshold(预定阈值).</p>',9),me=s('<h2 id="connection-oriented-transport-tcp" tabindex="-1"><a class="header-anchor" href="#connection-oriented-transport-tcp" aria-hidden="true">#</a> Connection-oriented transport: TCP</h2><h3 id="tcp-overview" tabindex="-1"><a class="header-anchor" href="#tcp-overview" aria-hidden="true">#</a> TCP: Overview</h3><ul><li><p><strong>point-to-point(端对端)</strong>: one sender, one receiver</p></li><li><p><strong>reliable, in-order byte steam(可靠的传输)</strong>: no “message ”(消息边界)</p></li><li><p><strong>pipelined(最大阈值控制)</strong>: TCP congestion and flow control set window size</p></li><li><p><strong>full duplex data(全双工数据)</strong>:</p><ul><li>bi-directional data flow(双向数据流) in same connection</li><li>MSS: maximum segment size(最大分段大小)</li></ul></li><li><p><strong>connection-oriented(以连接为导向)</strong>: handshaking (exchange of control msgs) inits sender, receiver state before data exchange</p></li><li><p><strong>flow controlled(流量控制)</strong>: sender will not overwhelm receiver</p></li></ul><h3 id="segment-structure" tabindex="-1"><a class="header-anchor" href="#segment-structure" aria-hidden="true">#</a> Segment structure</h3><p><img src="'+S+'" alt="image-20230406181022884" loading="lazy"></p>',5),ue=e("h3",{id:"packet-format",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#packet-format","aria-hidden":"true"},"#"),t(" Packet format")],-1),ge={href:"https://www.khanacademy.org/a/ip-packets",target:"_blank",rel:"noopener noreferrer"},fe=e("strong",null,"TCP segment(TCP 段)",-1),be=e("p",null,[e("img",{src:N,alt:"e5fdf560fdb40a1c0b3c3ce96f570e5f00fff161",loading:"lazy"})],-1),_e=e("p",null,"Each TCP segment contains a header and data. The TCP header contains many more fields than the UDP header and can range in size from 202020 to 606060 bytes, depending on the size of the options field(选项字段大小).",-1),ke={href:"https://www.khanacademy.org/a/user-datagram-protocol-udp",target:"_blank",rel:"noopener noreferrer"},we=s('<h3 id="from-start-to-finish" tabindex="-1"><a class="header-anchor" href="#from-start-to-finish" aria-hidden="true">#</a> From start to finish</h3><p>Let&#39;s step through the process of transmitting a packet with TCP/IP.</p><h4 id="step-1-establish-connection-建立连接" tabindex="-1"><a class="header-anchor" href="#step-1-establish-connection-建立连接" aria-hidden="true">#</a> Step 1: Establish connection(建立连接)</h4><p>When two computers want to send data to each other over TCP, they first need to establish(建立) a connection using a <strong>three-way handshake(3 次握手)</strong>.</p><p><img src="'+E+'" alt="image" loading="lazy"></p><p>The first computer sends a packet with the SYN bit set to 111 (SYN = &quot;synchronize(同步吗)?&quot;). The second computer sends back a packet with the ACK bit set to 111 (ACK = &quot;acknowledge!&quot;) plus the SYN bit set to 111. The first computer replies back with an ACK.</p><p>The SYN and ACK bits are both part of the TCP header:</p><p>![image (1)](./03-transport-layer.assets/image (1).png)</p><p>In fact, the three packets involved in the three-way handshake do not typically(通常) include any data. Once the computers are done with the handshake, they&#39;re ready to receive packets containing actual data(包含实际数据).</p><h4 id="step-2-send-packets-of-data" tabindex="-1"><a class="header-anchor" href="#step-2-send-packets-of-data" aria-hidden="true">#</a> Step 2: Send packets of data</h4><p>When a packet of data is sent over TCP, the recipient(收件人) must always acknowledge what they received.</p><p>![image (2)](./03-transport-layer.assets/image (2).png)</p><p>The first computer sends a packet with data and a sequence number. The second computer acknowledges it by setting the ACK bit and increasing the acknowledgement number by the length of the received data.</p><p>The sequence and acknowledgement numbers are part of the TCP header:</p><p>![image (3)](./03-transport-layer.assets/image (3).png)</p><p>Those two numbers help the computers to keep track of which data was successfully received, which data was lost, and which data was accidentally(意外地) sent twice.</p><h4 id="step-3-close-the-connection" tabindex="-1"><a class="header-anchor" href="#step-3-close-the-connection" aria-hidden="true">#</a> Step 3: Close the connection</h4><p>Either(任意一台) computer can close the connection when they no longer want to send or receive data.</p><p>![image (4)](./03-transport-layer.assets/image (4).png)</p><p>A computer initiates closing the connection by sending a packet with the FIN bit set to 1 (FIN = finish). The other computer replies with an ACK and another FIN. After one more ACK from the initiating computer, the connection is closed.</p><h3 id="detecting-lost-packets" tabindex="-1"><a class="header-anchor" href="#detecting-lost-packets" aria-hidden="true">#</a> Detecting lost packets</h3><p>TCP connections can detect lost packets using a <strong>timeout</strong>.</p><p>![image (5)](./03-transport-layer.assets/image (5).png)</p><p>After sending off a packet, the sender starts a timer and puts the packet in a retransmission queue(传输队列). If the timer runs out and the sender has not yet received an ACK from the recipient, it sends the packet again.</p><p>The retransmission may lead to the recipient receiving duplicate packets, if a packet was not actually lost but just very slow to arrive or be acknowledged. If so, the recipient can simply discard(丢弃) duplicate packets. It&#39;s better to have the data twice than not at all!</p><h3 id="handling-out-of-order-packets" tabindex="-1"><a class="header-anchor" href="#handling-out-of-order-packets" aria-hidden="true">#</a> Handling out of order packets</h3><p>TCP connections can detect out of order(乱序) packets by using the sequence(序列) and acknowledgement numbers.</p><p>![image (6)](./03-transport-layer.assets/image (6).png)</p><p>When the recipient sees a higher sequence number than what they have acknowledged so far, they know that they are missing at least one packet in between. In the situation pictured above, the recipient sees a sequence number of #73 but expected a sequence number of #37. The recipient lets the sender know there&#39;s something amiss(错误，有什么不对劲) by sending a packet with an acknowledgement number set to the expected sequence number.</p><p>Sometimes the missing packet is simply taking a slower route through the Internet and it arrives soon after.</p><p>![image (7)](./03-transport-layer.assets/image (7).png)</p><p>Other times, the missing packet may actually be a lost packet and the sender must retransmit the packet.</p><p>![image (8)](./03-transport-layer.assets/image (8).png)</p><p>In both situations, the recipient has to deal with out of order packets. Fortunately, the recipient can use the sequence numbers to reassemble(重新组装) the packet data in the correct order.</p><p>![image (9)](./03-transport-layer.assets/image (9).png)</p>',35),ye=s('<h4 id="tcp-round-trip-time-timeout" tabindex="-1"><a class="header-anchor" href="#tcp-round-trip-time-timeout" aria-hidden="true">#</a> TCP round trip time, timeout</h4><p>How to set TCP timeout value?</p><ul><li>longer than RTT(Round-Trip Time) (but RTT varies(是变化的))</li><li>too short: premature(过早的) timeout, unnecessary retransmissions(不必要的重发)</li><li>too long: slow reaction(反应缓慢) to segment loss(片段损失)</li></ul><p>How to estimate RTT?</p><ul><li><p>SampleRTT: measured time(测量时间) from segment transmission until ACK receipt (ignore retransmissions)</p></li><li><p>SampleRTT will vary, want estimated(估计的) RTT “smoother”</p><p>average several recent measurements(对最近的几个测量值进行取平均), not just current SampleRTT</p></li></ul>',5),Ae=e("p",{class:"katex-block"},[e("span",{class:"katex-display"},[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[e("semantics",null,[e("mrow",null,[e("mi",null,"E"),e("mi",null,"s"),e("mi",null,"t"),e("mi",null,"i"),e("mi",null,"m"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"e"),e("mi",null,"d"),e("mi",null,"R"),e("mi",null,"T"),e("mi",null,"T"),e("mo",null,"="),e("mo",{stretchy:"false"},"("),e("mn",null,"1"),e("mo",null,"−"),e("mi",null,"α"),e("mo",{stretchy:"false"},")"),e("mo",null,"∗"),e("mi",null,"E"),e("mi",null,"s"),e("mi",null,"t"),e("mi",null,"i"),e("mi",null,"m"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"e"),e("mi",null,"d"),e("mi",null,"R"),e("mi",null,"T"),e("mi",null,"T"),e("mo",null,"+"),e("mi",null,"α"),e("mo",null,"∗"),e("mi",null,"S"),e("mi",null,"a"),e("mi",null,"m"),e("mi",null,"p"),e("mi",null,"l"),e("mi",null,"e"),e("mi",null,"R"),e("mi",null,"T"),e("mi",null,"T")]),e("annotation",{encoding:"application/x-tex"}," EstimatedRTT = (1 - \\alpha) * EstimatedRTT + \\alpha * SampleRTT ")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6944em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),e("span",{class:"mord mathnormal"},"s"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mord mathnormal"},"ima"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mord mathnormal"},"e"),e("span",{class:"mord mathnormal"},"d"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"RTT"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),e("span",{class:"mrel"},"="),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mopen"},"("),e("span",{class:"mord"},"1"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"−"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),e("span",{class:"mclose"},")"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"∗"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"E"),e("span",{class:"mord mathnormal"},"s"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mord mathnormal"},"ima"),e("span",{class:"mord mathnormal"},"t"),e("span",{class:"mord mathnormal"},"e"),e("span",{class:"mord mathnormal"},"d"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"RTT"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"+"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.4653em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"∗"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),e("span",{class:"mord mathnormal"},"am"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"pl"),e("span",{class:"mord mathnormal"},"e"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"RTT")])])])])],-1),ve=e("p",null,[t("typical value: "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mi",null,"α")]),e("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.4306em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),t(" = 0.125")],-1),Ce=s('<p><img src="'+q+'" alt="image-20230413161231370" loading="lazy"></p><h3 id="reliable-data-transfer" tabindex="-1"><a class="header-anchor" href="#reliable-data-transfer" aria-hidden="true">#</a> Reliable data transfer</h3><p>TCP creates rdt service on top of(在…之上) IP’s unreliable service:</p><ul><li>pipelined segments(管道化分段传输)</li><li>cumulative acks(累积式确认应答)</li><li>single retransmission timer(单一重传计时器)</li></ul><p>retransmissions triggered by(由…触发):</p><ul><li>timeout events</li><li>duplicate acks(重复应答)</li></ul><h4 id="tcp-sender-simplified" tabindex="-1"><a class="header-anchor" href="#tcp-sender-simplified" aria-hidden="true">#</a> TCP sender (simplified)</h4><p><img src="'+F+'" alt="image-20230413162814647" loading="lazy"></p><h4 id="tcp-retransmission-scenarios" tabindex="-1"><a class="header-anchor" href="#tcp-retransmission-scenarios" aria-hidden="true">#</a> TCP: retransmission scenarios</h4><p><img src="'+R+'" alt="image-20230413163235946" loading="lazy"></p><h4 id="tcp-ack-generation" tabindex="-1"><a class="header-anchor" href="#tcp-ack-generation" aria-hidden="true">#</a> TCP ACK generation</h4><table><thead><tr><th>event at receiver</th><th>TCP receiver action</th></tr></thead><tbody><tr><td><strong>arrival of in-order segment</strong> with expected seq #(具有预期序号#). All data up to expected seq # already ACKed</td><td><strong>delayed ACK(延迟确认)</strong>. Wait up to 500ms for next segment. If no next segment, send ACK</td></tr><tr><td><strong>arrival of in-order segment(按顺序段到达)</strong> with expected seq #. One other segment has ACK pending(等待，悬而未决)</td><td><strong>immediately send single cumulative(累计的) ACK</strong>, ACKing both in-order segments</td></tr><tr><td><strong>arrival of out-of-order segment(无序段)</strong> higher-than-expect seq #(高于预期序号#). Gap detected(差异检测)</td><td><strong>immediately send duplicate ACK</strong>, indicating seq # of next expected byte</td></tr><tr><td><strong>arrival of segment</strong> that partially or completely(部分或完全) fills gap(填补缺口)</td><td>immediate send ACK, provided that segment starts at lower end of gap</td></tr></tbody></table>',12),xe={href:"https://zhuanlan.zhihu.com/p/135932018",target:"_blank",rel:"noopener noreferrer"},Te=e("p",null,"SACK 方法",-1),Pe=e("p",null,"还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。",-1),Ke=e("p",null,[t("这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它"),e("strong",null,"可以将缓存的地图发送给发送方"),t("，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以"),e("strong",null,"只重传丢失的数据"),t("。")],-1),ze=e("p",null,"如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。",-1),De=e("p",null,[e("img",{src:B,alt:"img",loading:"lazy"})],-1),Se=e("h3",{id:"flow-control",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#flow-control","aria-hidden":"true"},"#"),t(" Flow control")],-1),Ne={href:"https://zhuanlan.zhihu.com/p/135932018",target:"_blank",rel:"noopener noreferrer"},Ee=s('<p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>下面举个栗子，为了简单起见，假设以下场景：</p><ul><li>客户端是接收方，服务端是发送方</li><li>假设接收窗口和发送窗口相同，都为 200</li><li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li></ul><p><img src="'+I+'" alt="img" loading="lazy"></p><p>根据上图的流量控制，说明下每个过程：</p><ol><li>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。</li><li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列号是 321。</strong></li><li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，RCV.NXT 也就指向 321，<strong>这意味着客户端期望的下一个报文的序列号是 321</strong>，接着发送确认报文给服务端。</li><li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法在继续发送数据。</li><li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，RCV.NXT 也就指向 441，接着发送确认报文给服务端。</li><li>服务端收到对 80 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 321，于是可用窗口 Usable 增大到 80。</li><li>服务端收到对 120 字节数据的确认报文后，SND.UNA 指针往右偏移后指向 441，于是可用窗口 Usable 增大到 200。</li><li>服务端可以继续发送了，于是发送了 160 字节的数据后，SND.NXT 指向 601，于是可用窗口 Usable 减少到 40。</li><li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，RCV.NXT 也就是指向了 601，接着发送确认报文给服务端。</li><li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 SND.UNA 指针偏移了 160 后指向 601，可用窗口 Usable 也就增大至了 200。</li></ol><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p>',8),qe=e("h3",{id:"connection-management",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#connection-management","aria-hidden":"true"},"#"),t(" Connection Management")],-1),Fe=e("p",null,"Before exchanging data, sender/receiver “handshake”:",-1),Re=e("ul",null,[e("li",null,"Agree to establish(建立) connection (each knowing the other willing to establish connection)"),e("li",null,"Agree on connection parameters")],-1),Be=e("p",null,"详见：",-1),Ie=e("li",null,[e("a",{href:"#packet-format"},"Chapter3 @ Packet format")],-1),Oe=e("p",null,"三次握手：",-1),Ue=e("p",null,[e("img",{src:O,alt:"image-20230413173431851",loading:"lazy"})],-1),Ye=e("p",null,"四次挥手：",-1),He=e("p",null,[e("img",{src:U,alt:"image-20230413173420182",loading:"lazy"})],-1),Qe=e("h2",{id:"principles-of-congestion-control",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#principles-of-congestion-control","aria-hidden":"true"},"#"),t(" Principles of congestion control")],-1),je={href:"https://zhuanlan.zhihu.com/p/102175027",target:"_blank",rel:"noopener noreferrer"},Me=s('<h3 id="流量控制与拥塞控制" tabindex="-1"><a class="header-anchor" href="#流量控制与拥塞控制" aria-hidden="true">#</a> 流量控制与拥塞控制</h3><p>流量控制（flow control）: 接收端告诉发送端该发多少，解决发送方和接收方速率不匹配的问题，通过滑动窗口或者其他措施限制发送端的速率。</p><ul><li><strong>作用：控制发送方的窗口大小，让接收方来得及接收。</strong></li><li>控制对象：流量控制是点对点的，只控制一个发送端。</li><li>实现原理：通过滑动窗口就可以实现，接收方告知发送方自己的窗口大小，发送方立刻更改即可实现流量控制。</li></ul><p>拥塞控制（congestion control）：为了避免网络资源被耗尽的问题，通过拥塞窗口或者其他方法感知和调整网络的状态。</p><ul><li><strong>作用：避免给整体的网络造成较大的堵塞。</strong></li><li>控制对象：拥塞控制是全局的，涉及到所有的主机和网络因素。</li><li>实现原理：四种算法（慢开始，拥塞避免、快重传、快恢复）</li></ul><p>下面将详细讲解拥塞控制的四种算法。</p><h3 id="慢开始" tabindex="-1"><a class="header-anchor" href="#慢开始" aria-hidden="true">#</a> 慢开始</h3><p>发送方先探测一下网络的拥塞程度，并不是一开始就发送大量的数据，然后<strong>根据拥塞程度</strong>的增大或减小拥塞窗口。</p><h3 id="拥塞避免" tabindex="-1"><a class="header-anchor" href="#拥塞避免" aria-hidden="true">#</a> 拥塞避免</h3><p>该算法用来控制拥塞窗口的增长速率，每一次 RTT 往返之后，<strong>拥塞窗口 + 1 而不是翻倍</strong>，这样的话拥塞窗口以线性速率增长，流量可控。</p><h3 id="快重传" tabindex="-1"><a class="header-anchor" href="#快重传" aria-hidden="true">#</a> 快重传</h3><p>当发送方没有在超时期限内收到确认信号的话就认为网络阻塞了，此时拥塞窗口变为 1 ，同时把慢开始门限值 ssthresh 减半。</p><ul><li>拥塞窗口大小 &lt; ssthresh 时，使用慢开始算法</li><li>拥塞窗口大小 &gt; ssthresh 时，使用拥塞避免算法</li><li>拥塞窗口大小 = ssthresh 时，慢开始与拥塞避免算法均可</li></ul><p>接收方收到一个失序的报文段后就立刻发出重复确认，如下图，M3 丢失，会重复确认 M2</p><p><img src="'+Y+'" alt="img" loading="lazy"></p><p>一旦<strong>接收方连续 3 次收到</strong>同一个重复确认就会立马启动快重传算法，即立马重传 M3，而不会等待 M3 的超时时间到期。</p><h3 id="快恢复" tabindex="-1"><a class="header-anchor" href="#快恢复" aria-hidden="true">#</a> 快恢复</h3><p>快恢复是<strong>配合快重传使用</strong>的。</p><p>上图所示的 M3 丢失，可能是因为 M3 在某个节点因为网络波动等非网络拥挤情况阻塞住了。</p><p>也就是网络其实并没有拥塞，快恢复就是在此情况下避免直接重传会真正导致网络阻塞，其原理就是<strong>先将拥塞窗口设置成 ssthresh 的大小，然后执行拥塞避免算法</strong></p><h3 id="控制流程" tabindex="-1"><a class="header-anchor" href="#控制流程" aria-hidden="true">#</a> 控制流程</h3><p>下图展示了整个控制流程：</p><p><img src="'+H+'" alt="img" loading="lazy"></p><h2 id="tcp-congestion-control" tabindex="-1"><a class="header-anchor" href="#tcp-congestion-control" aria-hidden="true">#</a> TCP congestion control</h2>',24),Ge={href:"https://blog.csdn.net/qq_41431406/article/details/97926927",target:"_blank",rel:"noopener noreferrer"},Le=e("em",null,"tcp 拥塞控制",-1),Ve=e("p",null,"待补充。",-1);function Xe(Ze,We){const n=r("ExternalLinkIcon"),i=r("RouterLink");return d(),c("div",null,[j,e("blockquote",null,[e("p",null,[e("a",M,[t("计算机网络：多路复用（Multiplexing） VS 多路分解（Demultiplexing）_计算机 demultiplexing_SongXJ--的博客-CSDN 博客"),a(n)])]),G]),L,e("blockquote",null,[e("p",null,[e("a",V,[t("Segmentation Explained with TCP and UDP Header (computernetworkingnotes.com)"),a(n)])]),X]),Z,e("p",null,[t("部分内容来自 "),e("a",W,[t("网络协议 7：【传输层】可靠传输（rdt）的原理 - 掘金 (juejin.cn)"),a(n)]),t("，有删改")]),J,e("blockquote",null,[e("p",null,[e("a",$,[t("RDT 协议（可靠数据传输协议）_计算机网络 rdt_remiliko 的博客-CSDN 博客"),a(n)])]),ee]),te,e("blockquote",null,[e("p",null,[e("a",ae,[t("Go-Back-N Protocol | Baeldung on Computer Science"),a(n)])]),ne]),se,ie,e("blockquote",null,[e("p",null,[e("a",re,[t("Selective Repeat Protocol | Baeldung on Computer Science"),a(n)])]),e("p",null,[t("Selective Repeat Protocol (SRP) is a type of "),e("a",oe,[t("error control protocol"),a(n)]),t(" we use in computer networks to ensure the reliable delivery of data packets. Additionally, "),e("strong",null,[t("we use it in conjunction(结合) with the "),e("a",le,[t("Transmission Control Protocol (TCP)"),a(n)]),t(" to ensure that the receiver receives data transmitted over the network without errors.")])]),e("p",null,[t("In the SRP, the sender divides the data into packets and sends them to the receiver. Furthermore(此外), the receiver sends an "),e("a",de,[t("acknowledgment (ACK)"),a(n)]),t(" for each packet received successfully. If the sender doesn’t receive an ACK for a particular packet, it retransmits only that packet instead of the entire set of packets.")]),e("p",null,[t("The SRP uses a window-based(基于窗口的) "),e("a",ce,[t("flow control mechanism(流量控制机制)"),a(n)]),t(" to ensure the sender doesn’t overwhelm(充溢，淹没) the receiver with too many packets. Additionally, "),pe,t(" Based on the window size, the sender sends packets and waits for a specific amount of time for acknowledgment from the receiver.")]),he]),me,e("blockquote",null,[ue,e("p",null,[t("When sending packets using TCP/IP, the data portion of each "),e("a",ge,[t("IP packet"),a(n)]),t(" is formatted as a "),fe,t(".")]),be,_e,e("p",null,[t("The TCP header shares some fields with the UDP header: source port number, destination port number, and checksum. To remember how those are used, review the "),e("a",ke,[t("UDP article"),a(n)]),t(".")]),we]),ye,Ae,ve,Ce,e("blockquote",null,[e("p",null,[e("a",xe,[t("图解 TCP 重传、滑动窗口、流量控制、拥塞控制 - 知乎 (zhihu.com)"),a(n)])]),Te,Pe,Ke,ze,De]),Se,e("blockquote",null,[e("p",null,[e("a",Ne,[t("图解 TCP 重传、滑动窗口、流量控制、拥塞控制 - 知乎 (zhihu.com)"),a(n)])]),Ee]),qe,Fe,Re,Be,e("ul",null,[e("li",null,[a(i,{to:"/02-application-layer.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"},{default:o(()=>[t("Chapter2 @ 建立连接（三次握手）")]),_:1})]),e("li",null,[a(i,{to:"/02-application-layer.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"},{default:o(()=>[t("Chapter2 @ 断开连接（四次挥手）")]),_:1})]),Ie]),Oe,Ue,Ye,He,Qe,e("p",null,[t("参考："),e("a",je,[t("一分钟搞懂流量控制与拥塞控制 - 知乎 (zhihu.com)"),a(n)]),t("，有删改。")]),Me,e("p",null,[e("a",Ge,[t("TCP 的拥塞控制（详解）"),Le,t("一颗程序媛 0915 的博客-CSDN 博客"),a(n)])]),Ve])}const $e=l(Q,[["render",Xe],["__file","03-transport-layer.html.vue"]]);export{$e as default};

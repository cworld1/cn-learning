import{_ as n,M as s,p as o,q as l,R as e,t,N as a,a1 as i}from"./framework-5866ffd3.js";const d="data:image/png;base64,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",p="/assets/6d5c25bbe2e5400fbc9335d7050819c1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-bc291cbe.webp",c="/assets/image-20230330182543746-18712684.png",h="/assets/image-20230406160254181-f81eb35b.png",u="/assets/image-20230406160405036-eb4b4836.png",m="/assets/a09a430b0b4b42d8adaebd53c2d18ca7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-96145c6c.webp",g="/assets/2f304e43b0aa44fba18c7957739b64c3tplv-k3u1fbpfcp-zoom-in-crop-mark4536000-a1fdc17c.webp",f="/assets/388b53a2a1754fa3917c73567a08635etplv-k3u1fbpfcp-zoom-in-crop-mark4536000-4d01f083.webp",_="/assets/41aa6511fa604ded83b8a5cc70638a5dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000-a80fd8e1.webp",b="/assets/8cc24713a4d94435a4c38bcb73f2fb1ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000-bd0bdca1.webp",k="/assets/cd9a09430db5426da3258968f0138b4ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000-580e2873.webp",w="/assets/image-20230406170657367-fc64aa3a.png",A="/assets/image-20230406170731751-1680772053149-27-369c27d5.png",v="/assets/image-20230406170943445-dcb135e9.png",x="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1df09bec.png",C="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771028064-15-ab904db4.png",K="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771156231-18-20422705.png",y="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771627922-21-140cf4be.png",D="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAcmVtaWxpa28__size_20_color_FFFFFF_t_70_g_se_x_16-1680771724108-24-fe2c1379.png",P="/assets/GoBackN-4-2fa67c1c.webp",T={},F=i('<h1 id="chapter-3-transport-layer" tabindex="-1"><a class="header-anchor" href="#chapter-3-transport-layer" aria-hidden="true">#</a> Chapter 3: Transport Layer</h1><h2 id="outline" tabindex="-1"><a class="header-anchor" href="#outline" aria-hidden="true">#</a> Outline</h2><ol><li><p>Transport-layer services</p></li><li><p>Multiplexing and demultiplexing</p></li><li><p>Connectionless transport: UDP</p></li><li><p>Principles of reliable data transfer</p></li><li><p>Connection-oriented transport: TCP</p><ul><li>segment structure</li><li>reliable data transfer</li><li>flow control</li><li>connection management</li></ul></li><li><p>Principles of congestion control</p></li><li><p>TCP congestion control</p></li></ol><h2 id="transport-layer-services" tabindex="-1"><a class="header-anchor" href="#transport-layer-services" aria-hidden="true">#</a> Transport-layer services</h2><h3 id="transport-vs-network-layer" tabindex="-1"><a class="header-anchor" href="#transport-vs-network-layer" aria-hidden="true">#</a> Transport vs. network layer</h3><p>网络层是协议栈中的第三层，负责处理互联网上每个主机之间的路由。该层有两个主要的任务：</p><ol><li>选择最佳路径将数据包发送到目标地址；</li><li>控制每个数据包在网络中的传输。网络层协议常用的是 IP（Internet Protocol），它定义了如何通过互联网把数据包从源主机传输到目标主机。</li></ol><p>传输层是协议栈中的第四层，是端到端通信的主要协议。传输层实现了数据传输的可靠性，并采用流控制和拥塞控制等机制来协调系统中的数据流。该层的两个最常用的协议是 TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）。TCP 提供可靠的数据传输，而 UDP 则提供无连接、不可靠和基于报文的传输。</p><p>因此，网络层和传输层具有不同的目的和职责。网络层处理路由和数据包转发，而传输层负责端到端通信可靠性，数据流控制和拥塞控制等方面的任务。</p><h2 id="multiplexing-and-demultiplexing" tabindex="-1"><a class="header-anchor" href="#multiplexing-and-demultiplexing" aria-hidden="true">#</a> Multiplexing and demultiplexing</h2>',10),N={href:"https://blog.csdn.net/SongXJ_01/article/details/106880461",target:"_blank",rel:"noopener noreferrer"},z=i('<h3 id="multiplexing-多路复用" tabindex="-1"><a class="header-anchor" href="#multiplexing-多路复用" aria-hidden="true">#</a> Multiplexing 多路复用</h3><p>从源主机的不同套接字（socket）中收集数据块，并为每个数据块封装上首部信息（这将在多路分解时使用）从而生成报文段（segment），然后将报文段传递到网络层的工作称为多路复用。</p><ul><li>在 TCP 或者 UDP 传输过程中，数据需要被不同程序识别，multiplexing 因此诞生</li><li>一般情况下 multiplexing 有以下几个 field 用于区分不同程序所需要的数据 source ip, source port, destination ip, destination port</li></ul><h3 id="demultiplexing-多路分解" tabindex="-1"><a class="header-anchor" href="#demultiplexing-多路分解" aria-hidden="true">#</a> Demultiplexing 多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><ul><li>通过检验上述 field, 传输协议（transport layer protocol）将不同数据包发送至正确的 socket port</li><li>0-1023 是被各种协议占用的端口，1024-65535 是一般程序可用的端口</li></ul>',6),B=i('<h2 id="connectionless-transport-udp" tabindex="-1"><a class="header-anchor" href="#connectionless-transport-udp" aria-hidden="true">#</a> Connectionless transport: UDP</h2><h3 id="udp-user-datagram-protocol-rfc-768" tabindex="-1"><a class="header-anchor" href="#udp-user-datagram-protocol-rfc-768" aria-hidden="true">#</a> UDP: User Datagram Protocol [RFC 768]</h3><p>基础原理已经在 <a href="./02-application-layer#client-server-socket-udp">Chapter 2@Client/server socket: UDP</a> 讲过，不再赘述。</p><h3 id="udp-segment-header" tabindex="-1"><a class="header-anchor" href="#udp-segment-header" aria-hidden="true">#</a> UDP: segment header</h3>',4),S={href:"https://www.computernetworkingnotes.com/ccna-study-guide/segmentation-explained-with-tcp-and-udp-header.html",target:"_blank",rel:"noopener noreferrer"},I=i('<h3 id="segmentation" tabindex="-1"><a class="header-anchor" href="#segmentation" aria-hidden="true">#</a> Segmentation</h3><p>Segmentation is the process of dividing large data stream into smaller pieces. This functionality allows a host to send or receive a file of any size over the any size of network. For example, if network bandwidth is 1 Mbps and file size is 100 Mb, host can divide the file in 100 or more pieces. Once a piece becomes less or equal to the network bandwidth in size, it can be transferred easily. Destination host, upon(在…之后) receiving all pieces, joins them back to reproduce the original file.</p><p>If an application wants to use UDP to send its data, it can’t give the data to UDP in actual size. It has to use its own mechanism(机制) to detect whether segmentation is required or not. And if segmentation is required, it has to do it on its own before giving data to UDP.</p><h3 id="packing-data-for-transmission" tabindex="-1"><a class="header-anchor" href="#packing-data-for-transmission" aria-hidden="true">#</a> Packing data for transmission</h3><p>Both protocols pack data in similar fashion. Both add a header with each data piece. A header mainly contains two types of information;</p><ol><li>The information that is required to send the segment at the correct destination.</li><li>The information that is required to support the protocol specific features.</li></ol><h3 id="how-udp-work-with-header" tabindex="-1"><a class="header-anchor" href="#how-udp-work-with-header" aria-hidden="true">#</a> How UDP Work with header</h3><p>UDP neither provides any protocol specific service, nor adds any additional information in the header.</p><p>Following figure shows data with UDP header.</p><p><img src="'+d+'" alt="UDP header"></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Source port</td><td>Port number of the application that is transmitting data from the source computer</td></tr><tr><td>Destination port</td><td>Port number of the application that will receive the data at destination.</td></tr><tr><td>Length</td><td>Denotes the length of the UDP header and the UDP data</td></tr><tr><td>Checksum</td><td>CRC of the complete segment</td></tr><tr><td>Data</td><td>Data which it received from the application</td></tr></tbody></table>',11),O=i('<h3 id="udp-checksum" tabindex="-1"><a class="header-anchor" href="#udp-checksum" aria-hidden="true">#</a> UDP checksum</h3><p>Goal: detect “errors” (e.g., flipped bits(比特位的翻转)) in transmitted segment</p><p>UDP（用户数据报协议）checksum 是一种用于检测 UDP 数据包完整性的简单校验和。当 UDP 数据包被发送到网络时，发送端计算校验和并将其添加到 UDP 数据包中的 checksum 字段中。接收端通过再次计算校验和并将其与数据包的 checksum 字段进行比较来检测数据包是否在传输过程中出现任何错误或损坏。如果计算出的校验和不匹配，则数据包被认为是损坏的。UDP 校验和是 UDP 协议的一项重要功能，可确保数据在传输过程中的完整性和正确性。</p><h2 id="principles-of-reliable-data-transfer" tabindex="-1"><a class="header-anchor" href="#principles-of-reliable-data-transfer" aria-hidden="true">#</a> Principles of reliable data transfer</h2><p>Characteristics(特点) of unreliable channel will determine(决定) complexity of reliable data transfer protocol.</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Reliable data transfer(rdt) 即可靠传输。</p></div>',6),q={href:"https://juejin.cn/post/7030066301062086670",target:"_blank",rel:"noopener noreferrer"},E=i('<p><img src="'+p+'" alt="image.png"></p><h3 id="rdt-1-0" tabindex="-1"><a class="header-anchor" href="#rdt-1-0" aria-hidden="true">#</a> rdt 1.0</h3><p>rdt 1.0 是基于<strong>理想情况下</strong>的协议，假设所有信道都是可靠的——没有比特位的翻转，没有数据包的丢失与超时。所以 rdt 1.0 的传输功能就是：<strong>发送方发送数据，接收方等着接受数据</strong>。</p><p><img src="'+c+'" alt="image-20230330182543746"></p><h3 id="rdt-2-0" tabindex="-1"><a class="header-anchor" href="#rdt-2-0" aria-hidden="true">#</a> rdt 2.0</h3><ul><li>rdt 2.0 在 rdt1.0 的基础上考虑了 <strong>bit errors</strong>，即，不可信信道中数据包中的 1 可能会变 0，0 可能会变成 1。rdt2.0 的任务是<strong>发现并修复</strong>这些 bit errors</li><li>rdt 1.0 中接受者和发送者固定，rdt2.0 引入有限状态自动机 finite state machines (FSM) 来切换指定发送者和接受者</li></ul><div class="custom-container tip"><p class="custom-container-title">Finite State Machines</p><p>即只有有限种状态的，在特定条件下能切换状态的机器。比如刷卡就转的这种门禁机器。</p></div><p>rdt 2.0 增加了 3 种新机制来提升：</p><ol><li><p>通过 checksum 来错误校验</p></li><li><p>接收者反馈接受正误信息（Acknowledgements）：</p><ul><li>acknowledgements (ACKs): receiver explicitly(明确地) tells sender that pkt() received OK</li><li>negative acknowledgements (NAKs): receiver explicitly tells sender that pkt had errors</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>这也叫做停等协议（Stop and wait）：</p><p>sender sends one packet, then waits for receiver response</p></div></li><li><p>出错就重传</p></li></ol><p>即，传输层对应用层的数据进行打包处理时，新增 checksum（校验和），从而接收端可以对其数据包进行检验，如果正确，返回 ACK，发送者继续发送下一个数据包；如果不正确，返回 NAK，发送者重传数据。</p><p><img src="'+h+'" alt="image-20230406160254181"></p><p>但如果客户端在接受后反馈信息 ACKs 在传输过程中出现问题，导致回答的内容在服务端看来并非 ACKs，服务端/发送端会重新回传内容。</p><p><img src="'+u+'" alt="image-20230406160405036"></p><p>这也是 rdt 2.0 的一些大问题。不能只是简单地重发，可能重复了就麻烦了。因此 rdt 2.1 应运而生。</p><h3 id="rdt2-1" tabindex="-1"><a class="header-anchor" href="#rdt2-1" aria-hidden="true">#</a> rdt2.1</h3><p>如何解决重复呢：</p><ul><li>如果 ACK 或者 NAK 错了，corrupted(损坏) 了，还是重发</li><li>但是这回，发送方在打包数据包时添加了 0 或者 1 编号 sequence number (seq) <ul><li>两个状态就够啦，一次只发送一个未经确认的分组</li></ul></li><li>sender 就有 0 号数据包和 1 号 package 两种；receiver 也有了 2 种状态等待 0 号 package 和等待 1 号 package</li><li>receiver 把序列重复的删了不接受即可 <ul><li>receiver 也不知道发送方是否正确收到了其 ACK/NAK</li></ul></li><li>需要“stop and wait”，发送方发送一个 package，然后等待接收方响应</li></ul><p>对于 Sender：</p><p><img src="'+m+'" alt="image.png"></p><p>对于 Receiver：</p><p><img src="'+g+'" alt="image.png"></p><p>整体（基本上记这个就差不多）：</p><p><img src="'+f+'" alt="image.png"></p><h3 id="rdt-2-2" tabindex="-1"><a class="header-anchor" href="#rdt-2-2" aria-hidden="true">#</a> rdt 2.2</h3><p>做了一点点微不足道的改进，再见啦 NAK，ACK 就够了</p><p><strong>我们在 ACK 的信息上加上了顺序号</strong>：sender 发送 0 号数据包，如果接收方正确接收到 0 号，返回（ACK0），发送方接着发送 1 号数据包。如果接收方没有接收到 0 号数据包或出现错误，返回（ACK1），发送方重传 0 号数据包。</p><p><strong>相当于抽象成了“若不符合要求，重发”和“发新的”两个选项</strong></p><p><img src="'+_+'" alt="image.png"></p><p><img src="'+b+'" alt="image.png"></p><p><img src="'+k+'" alt="image.png"></p><h3 id="rdt3-0" tabindex="-1"><a class="header-anchor" href="#rdt3-0" aria-hidden="true">#</a> rdt3.0</h3><p>rdt2.2 之前的版本都重在处理数据包的 bit errors 情况，却没有考虑到数据包在传输过程中出现的<strong>数据包或者 ACKs 丢失</strong>问题，这样数据包丢失会使得网络处于拥塞状态</p><p>机制（解决方法）：在超过合理时间（reasonable amount of time，同 TCP）后重传</p><ul><li>发送端超时重传：如果到时没有收到 ACK-&gt;重传</li><li>如果 package（或 ACK）只是被延迟了： <ul><li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li><li>接收方必须指明被正确接收的序列号</li></ul></li><li>需要一个倒计数定时器</li></ul><p><img src="'+w+'" alt="image-20230406170657367"></p><p><img src="'+A+'" alt="image-20230406170731751"></p><p><img src="'+v+'" alt="image-20230406170943445"></p><p>过早超时(延迟的 ACK)也能够正常工作：但是效率较低，一半包和确认是重复的。</p>',38),R={href:"https://blog.csdn.net/m0_63657524/article/details/121916128",target:"_blank",rel:"noopener noreferrer"},Y=i('<p>计算机网络通过对网络进行分层设计，将一个庞大而复杂的系统，模块化层次化，（ 大致分层如图 2.1 所示 ） 其中的每个层次为其上层提供特定的服务内容，并使用来自下层的特定功能，各个层次中明确了其需要实现的内容，但并不指明其中具体的实现方式。</p><p>运行在应用层中的客户端（服务端）应用程序进程通过套接字将数据推送到运输层。同样地，有服务端（客户端）进程通过套接字接受来自运输层的数据。对应用层而言，它所能看到的底层就是一条可靠的信道（如图 2.2 所示）。但是，对于现实中的数据传输，由于受到噪声干扰、网络拥堵等各种影响，难免会出现数据受损、丢包等事故，而 rdt 协议就是为了解决这样一个问题，而诞生的。</p><p><img src="'+x+'" alt="img"></p><p>rdt 协议的实现</p><p>参考《计算机网络自顶向下》这本书，在这里我们从简单到复杂来探讨这个协议的实现过程（要注意的是，我们在此处探讨的 rdt 协议是建立在（stop-and-wait）停等协议上的)</p><p>首先，先将各个部分做好定义和命名初始化处理, 为进一步探讨协议做好准备。</p><p>我们将数据的发送方设定为 sender，接收方设定为 receptor，发送方和接收方各自维护一个自己 FSM(Finite-State-Machine)有限状态机，用于记录当前的状态。我们用状态来描述发送方和接收方在执行通讯各个时期的特征。</p><h3 id="rdt-1-0-1" tabindex="-1"><a class="header-anchor" href="#rdt-1-0-1" aria-hidden="true">#</a> rdt 1.0</h3><p>在 rdt 1.0 中我们只专注于考虑如何实现核心功能，而不去考虑其他异常。因此我们在此处假定两个应用层之间存在着这么一条可靠信道，它可以保证从应用层的一侧到另一侧数据不丢失，因此此时的发送方和接收方只会有一个状态。</p><ul><li><p>发送方： 等待应用程序下发调用指令，发送数据</p></li><li><p>接收方： 等待来自下层的调用指令，接受数据并缓存</p></li></ul><p><img src="'+C+'" alt="img"></p><p>数据流动情况分析</p><p>sender：</p><ul><li>应用进程调用 rdt_send（data）方法，将数据推送至运输层</li><li>运输层调用 make_pkt 方法，将源自于应用程序的报文分组打包成报文段</li><li>运输层调用 udt_send 方法，将报文段推送至信道</li></ul><p>receptor：</p><ul><li>较低层（比运输层低的层次）执行 ret_rev 方法，将数据推送到运输层</li><li>运输层调用 extract，从报文段中提取出数据（可能涉及分组等细节实现，此处不作探讨）</li><li>运输层调用 deliver_data 方法将数据推送至应用层</li></ul><p>此时，我们就可以简单地实现让数据从 sender 端传输到 receptor 端了，当然此时距离可靠数据传输还有一定的距离。因此，在 rdt2.0 及以后的版本我们开始考虑当异常事件发生的时候，如何保证数据的可靠性</p><h3 id="rdt-2-0-1" tabindex="-1"><a class="header-anchor" href="#rdt-2-0-1" aria-hidden="true">#</a> rdt 2.0</h3><p>在 rdt 2.0 首先考虑比特差错出现的情况，比特差错通常会出现在可能受损的物理部件之中，因此需要引入比特差错矫正的功能。（udp 的比特差错校验方法）在考虑出现比特差错事件发生的 rdt 2.0 中，需要加入 肯定确认（ACK positive acknowledgement）、否定确认（NAK negative acknowledgement）的情况。对于否定确认的报文，需要提示发送方重新发送该数据（数据恢复）。基于这种重传机制的可靠数据传输协议称为 自动重传协议（Automatic Repeat reQuest，ARQ）</p><p>于是 Sender 方需要增加一个状态，等待 ACK 或 NAK，整个 rdt 2.0 执行流程如图所示：</p><p><img src="'+K+'" alt="img"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li><p>应用层调用 rdt_send 方法，将数据推送至应用层</p></li><li><p>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码</p></li><li><p>应用层调用 udt_send 方法将打包完成的报文段推送至信道</p></li><li><p>Sender 端 此时状态迁移为 等待 ACK 应答 或者 NAK 应答状态</p></li></ul><p>Receptor 端：</p><ul><li>较低层通过 rdt_rcv 方法，将数据推送到运输层</li><li>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则跳转到第 3 步</li><li>发送 NAK 指令，继续等待较低层的调用</li><li>发送 ACK 指令，继续等待较低层的调用</li></ul><p>Sender 端：</p><ul><li>接收到 NAK 应答指令执行第 2 步，接收到 ACK 执行第 3 步</li><li>接收到 NAK，Sender 直接将打包好的数据再一次通过 udt_send 方法推送到信道, 保持等待 ACK 或 NAK 指令状态</li><li>接受到 ACK，Sender 端不再阻塞，可以发送新的数据，状态迁移为等待上层调用状态</li></ul><p>需要注意的是：由于在这里讨论的 rdt 协议采用了停等协议。因此，Sender 端在等待 ACK 和 NAK 答复指令的时候，处在阻塞的状态。</p><h3 id="rdt-2-1" tabindex="-1"><a class="header-anchor" href="#rdt-2-1" aria-hidden="true">#</a> rdt 2.1</h3><p>（rdt 2.1 为什么不效仿 rdt 2.0 中，让 receptor 端去接受一个 ack 或 nak，这是因为可能出现一个比较有趣的问题，这个问题后续讨论）</p><p>数据流动如图所示：</p><p><img src="'+y+'" alt="img"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li><p>应用层调用 rdt_send 方法，将数据推送至应用层</p></li><li><p>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码和一个值为 0 或 1 的序号</p></li><li><p>应用层调用 udt_send 方法将打包完成的报文段推送至信道</p></li><li><p>Sender 端 此时状态迁移为 等待序号为 0 或 1 的报文段 ACK 应答 或 NAK 应答状态</p></li></ul><p>Receptor 端：</p><ul><li><p>较低层通过 rdt_rcv 方法，将数据推送到运输层</p></li><li><p>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</p></li><li><p>发送 NAK 指令，继续等待下层调用</p></li><li><p>检测数据序号，如果是冗余数据，直接丢弃数据，发送对缓存栈中数据的 ACK 指令，对于非冗余数据，则将数据置换到缓存栈之中，发送一个确认对本次数据的 ACK 指令，继续等待来自下层的调用</p></li></ul><p>Sender 端：</p><ul><li>接收到应答指令后，进行数据校验处理，如果数据校验错误，直接重传上次数据，如果数据校验正确，则执行第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 执行第 3 步，如果指令为 NAK 执行第 4 步</li><li>接收到 ACK 指令，Sender 端不再阻塞，可以发送新的数据 1 或 0，状态迁移到 等待来自上层调用</li><li>接收到 NAK 指令，重传上次数据，状态迁移到：等待 ACK 或 NAK 状态</li></ul><h3 id="rdt-2-2-1" tabindex="-1"><a class="header-anchor" href="#rdt-2-2-1" aria-hidden="true">#</a> rdt 2.2</h3><p>实际上 rdt 2.2 并没有做出更多变更，它只是在 rdt2.1 基础上进行了一次逻辑优化，因为有了序号的存在，receptor 端不在需要用 NAK 指令去表示收到的数据产生了比特错误。 取而代之是，对于比特受损的数据，receptor 端直接丢弃，并发送一个对缓存区数据的确认 ACK（一开始缓存区为空也不要紧，由于序列是 010101 交替的序列，只要发送一个与当前 ACK 不同的序号即可），而此时，Sender 端也需要维护一个缓存，用于记录上一次发送的数据，当接受到的 ACK 与缓存序列号相同，那么就表示发送的数据发生了比特差错，此时重新发送一次缓存区中的数据即可。</p><p><img src="'+D+'" alt="img"></p><p>数据流动情况分析</p><p>Sender 端：</p><ul><li><p>应用层调用 rdt_send 方法，将数据推送至应用层</p></li><li><p>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码，和一个值为 0 或 1 的序号 ，并将其存储至缓存区</p></li><li><p>应用层调用 udt_send 方法将打包完成的报文段推送至信道</p></li><li><p>Sender 端 此时状态迁移为 等待序号为 0 或 1 的报文段 的 ACK 或 NAK 应答状态</p></li></ul><p>Repetor 端：</p><ul><li><p>较低层通过 rdt_rcv 方法，将数据推送到运输层</p></li><li><p>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</p></li><li><p>发送缓存区数据序号的确认 ACK 指令，保持等待下层调用的状态</p></li><li><p>检测本次数据序号，如果是冗余数据，直接丢弃数据，发送缓存栈中数据序号的 ACK 指令，对于非冗余数据，将数据置换到缓存区之中，并发送一个对本次数据序号的确认 ACK 指令</p></li></ul><p>Sender 端：</p><ul><li>接收到应答指令后进行数据校验处理，如果数据校验错误，直接重新发送上次数据，如果正确则执行第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 中的序号等于缓存区的序号，执行第 3 步，如果 ACK 指令序号不等于缓存区序号则执行 第 4 步</li><li>重新发送上次数据，状态迁移到 等待 ACK 应答指令</li><li>Sender 端不再阻塞，可以发送新的序号为 1 或者 0 的数据，状态迁移到 等待来自上层调用</li></ul><h3 id="rdt-3-0" tabindex="-1"><a class="header-anchor" href="#rdt-3-0" aria-hidden="true">#</a> rdt 3.0</h3><p>在处理好了比特差错的问题之后，需要考虑的就是来自底层信道传输的另一个问题，丢包异常（ 即发送方或者接受方由于网络阻塞等状况，并没有收到来自于对方的应答数据，在现实中丢包现象是非常常见的），因此，我们可以加入一个定时器来处理丢包现象，当发送一个报文段的时候，就开启一个定时器，在定时器结束期间，如果没有收到对应数据的应答报文，则重传数据。</p><p>数据流动分析</p><p>Sender 端：</p><ul><li><p>应用层调用 rdt_send 方法，将数据推送至应用层</p></li><li><p>应用层调用 make_pdt 将数据打包成报文段，并在报文段中封装进一个 校验码，和一个值为 0 或 1 的序号 ，并将其存储至缓存区</p></li><li><p>应用层调用 udt_send 方法将打包完成的报文段推送至信道，并启动一个定时器事件</p></li><li><p>Sender 端 此时状态迁移为 等待序号为 0 或 1 报文段 的 ACK 应答状态</p></li><li><p>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 步</p></li></ul><p>Receptor 端：</p><ul><li><p>较低层通过 rdt_rcv 方法，将数据推送到运输层</p></li><li><p>运输层接收到报文段，对报文段数据进行校验处理，校验成功则执行第 4 步，校验失败则执行第 3 步</p></li><li><p>发送缓存区数据序号的确认 ACK 指令, 同时开启一个定时器，保持等待下层调用的状态</p></li><li><p>检测数据序号，如果是冗余数据，直接丢弃数据，发送缓存区中数据序号的 ACK 指令，对于非冗余数据，将数据置换到缓存区中，发送一个对该数据序号的确认 ACK 指令，同时开启一个定时器</p></li><li><p>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 或第 4 步</p></li></ul><p>Sender 端</p><ul><li>接收到应答指令后进行数据校验处理，如果数据校验错误，直接重新发送上次数据，如果正确则执行步第 2 步</li><li>判断接受到的应答指令，如果指令为 ACK 中的序号等于缓存区的序号，执行第 3 步，如果 ACK 指令序号不等于缓存区序号则执行 4</li><li>重新发送上次数据，状态迁移到 等待 ACK，同时开启一个定时器</li><li>Sender 端不再阻塞，可以发送新的序号值为 1 或 0 的数据，状态迁移到 等待来自上层调用</li><li>倘若在定时器等待时间内，没有收到响应，则重新执行第 3 或第 4 步</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>至此，在 rdt 3.0 我们已经得到了一个可靠的数据传输协议，当然它只是一个抽象的雏形，建立于停等协议之上，还需要不少细致的优化，让其更好的切合现实，比如如何脱离停等协议实现更高的传输率，以及拥塞控制等等。文章内的方法为了保证准确性，表达式大多参照于《计算机网络自顶向下方法》书籍中的内容，但是为了简化一下表达，也做出了一点变更。</p>',61),U=i('<h3 id="pipelined-protocols" tabindex="-1"><a class="header-anchor" href="#pipelined-protocols" aria-hidden="true">#</a> Pipelined protocols</h3><p>Pipelined protocols(管道协议/窗口协议): sender allows multiple, “in-flight”, yet-to-be-acknowledged pkts</p><ul><li>range of sequence numbers must be increased</li><li>buffering at sender and/or receiver</li></ul><p>Two generic forms of pipelined protocols: go-Back-N(返回 N 个), selective repeat(选择重传)</p><p>Go-back-N(返回 N 个):</p><ul><li>sender can have up to N unACKed packets in pipeline</li><li>receiver only sends cumulative(累计的) ack: doesn’t ack packet if there’s a gap(有缺口的)</li><li>sender has timer for oldest unACKed packet: when timer expires, retransmit all unACKed packets</li></ul>',6),Q={href:"https://www.baeldung.com/cs/networking-go-back-n-protocol",target:"_blank",rel:"noopener noreferrer"},H=i('<p>Go-Back-N and Selective(选择性的) Repeat protocols are fundamental(基本的) sliding window protocols(窗口协议) that help us better understand the key idea behind reliable data transfer in the transport layer of computer networks.</p><p>The sliding window (pipelined) protocols achieve utilization(利用) of network bandwidth by not requiring the sender to wait for an acknowledgment before sending another frame.</p><p><strong>In Go-Back-N, the sender controls the flow of packets,</strong> <strong>meaning</strong> <strong>we’ve got a simple and dummy receiver.</strong> Therefore, we’ll start by discussing how the server handles(处理) data packets first.</p><h3 id="sender" tabindex="-1"><a class="header-anchor" href="#sender" aria-hidden="true">#</a> Sender</h3><p>The sender has a sequence of frames to send. We assume a window size of N. Furthermore, there exist two pointers to keep track of send base (send_base) and the next packet to send (nextseqnum).</p><p><img src="'+P+'" alt="GoBackN-4"></p><p>First of all, the sender starts by sending the first frame. Initially, send_base = 0 and nextseqnum = 0. While there are more packets to send and the nextseqnum is smaller than the send_base + N; the sender sends the packet pointed by the nextseqnum pointer and then increments(递增) the nextseqnum.</p><p>Meanwhile, the send_base is incremented after receiving acknowledgment packets from the receiver. The reception of duplicate ACK messages does not trigger any mechanism.</p><p>There is a single timer for the whole sending window, which measures the timeout for the packet at the send_base. Therefore, if a timeout occurs, the sender restarts the timer and re-transmits all the packets in the sending window starting from send_base.</p><h3 id="receiver" tabindex="-1"><a class="header-anchor" href="#receiver" aria-hidden="true">#</a> Receiver</h3><p>The receiver implementation(实施) of the Go-Back-N is as simple as possible:</p><p>The receiver only keeps track of the expected sequence number to receive next: nextseqnum.</p><p>There is no receiver buffer(缓冲区); out of order packets are simply discarded(丢弃掉). Similarly, corrupted packets are also silently discarded.</p><p>It always sends the acknowledgment for the last in-order packet received upon reception of a new packet (successfully or unsuccessfully). As a result, it will generate duplicate acknowledgment messages if something goes wrong.</p><p>The Go-Back-N protocol adopts the use of cumulative acknowledgments. That is, receiving acknowledgment for frame n means the frames n-1, n-2, and so on are acknowledged as well. We denote such acknowledgments as ACK n.</p>',15),j=e("p",null,"Selective Repeat(返回 N 个):",-1),G=e("ul",null,[e("li",null,"sender can have up to N unACKed packets in pipeline"),e("li",null,[t("receiver sends "),e("strong",null,"individual ack"),t(" for each packet")]),e("li",null,"sender maintains timer for each unACKed packet: when timer expires, retransmit only that unACKed packet")],-1),V={href:"https://www.baeldung.com/cs/selective-repeat-protocol",target:"_blank",rel:"noopener noreferrer"},L={href:"https://en.wikipedia.org/wiki/Error_detection_and_correction",target:"_blank",rel:"noopener noreferrer"},M={href:"https://www.baeldung.com/cs/udp-vs-tcp",target:"_blank",rel:"noopener noreferrer"},X={href:"https://www.baeldung.com/cs/tcp-protocol-syn-ack",target:"_blank",rel:"noopener noreferrer"},Z={href:"https://www.baeldung.com/cs/tcp-flow-control-vs-congestion-control",target:"_blank",rel:"noopener noreferrer"},W=e("strong",null,"the sender and receiver maintain a window of packets.",-1),J=e("p",null,"The receiver, in turn, maintains a window of packets that contains the frame number it’s receiving from the sender. If a frame is lost during transmission, the receiver sends the sender a negative acknowledgment attacking the frame number.",-1);function $(ee,te){const r=s("ExternalLinkIcon");return o(),l("div",null,[F,e("blockquote",null,[e("p",null,[e("a",N,[t("计算机网络：多路复用（Multiplexing） VS 多路分解（Demultiplexing）_计算机 demultiplexing_SongXJ--的博客-CSDN 博客"),a(r)])]),z]),B,e("blockquote",null,[e("p",null,[e("a",S,[t("Segmentation Explained with TCP and UDP Header (computernetworkingnotes.com)"),a(r)])]),I]),O,e("p",null,[t("部分内容来自 "),e("a",q,[t("网络协议 7：【传输层】可靠传输（rdt）的原理 - 掘金 (juejin.cn)"),a(r)]),t("，有删改")]),E,e("blockquote",null,[e("p",null,[e("a",R,[t("RDT 协议 （可靠数据传输协议）_计算机网络 rdt_remiliko 的博客-CSDN 博客"),a(r)])]),Y]),U,e("blockquote",null,[e("p",null,[e("a",Q,[t("Go-Back-N Protocol | Baeldung on Computer Science"),a(r)])]),H]),j,G,e("blockquote",null,[e("p",null,[e("a",V,[t("Selective Repeat Protocol | Baeldung on Computer Science"),a(r)])]),e("p",null,[t("Selective Repeat Protocol (SRP) is a type of "),e("a",L,[t("error control protocol"),a(r)]),t(" we use in computer networks to ensure the reliable delivery of data packets. Additionally, "),e("strong",null,[t("we use it in conjunction with the "),e("a",M,[t("Transmission Control Protocol (TCP)"),a(r)]),t(" to ensure that the receiver receives data transmitted over the network without errors.")])]),e("p",null,[t("In the SRP, the sender divides the data into packets and sends them to the receiver. Furthermore, the receiver sends an "),e("a",X,[t("acknowledgment (ACK)"),a(r)]),t(" for each packet received successfully. If the sender doesn’t receive an ACK for a particular packet, it retransmits only that packet instead of the entire set of packets.")]),e("p",null,[t("The SRP uses a window-based "),e("a",Z,[t("flow control mechanism"),a(r)]),t(" to ensure the sender doesn’t overwhelm the receiver with too many packets. Additionally, "),W,t(" Based on the window size, the sender sends packets and waits for a specific amount of time for acknowledgment from the receiver.")]),J])])}const ae=n(T,[["render",$],["__file","03-transport-layer.html.vue"]]);export{ae as default};
